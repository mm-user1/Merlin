# Обновленная архитектура и процесс подключения стратегий

## Как система устроена сейчас
- **UI**: динамический выбор стратегии, форма параметров и warmup генерируются из `config.json` выбранной стратегии, все запросы отправляют `strategy_id` и `warmup_bars` на сервер. 【F:info/ARCHITECTURE.md†L5-L184】【F:info/ARCHITECTURE.md†L200-L216】
- **Сервер**: новые эндпоинты `/api/strategies*` отдают метаданные и конфиг, а все рабочие эндпоинты принимают `strategy_id` и подгружают класс через реестр. 【F:info/ARCHITECTURE.md†L29-L44】【F:info/ARCHITECTURE.md†L49-L65】
- **Реестр стратегий**: автообнаружение директорий `src/strategies/*/` с двумя файлами (`config.json` и `strategy.py`) и выдача класса/конфига по идентификатору. 【F:info/ARCHITECTURE.md†L49-L95】
- **Движки**: backtest/optimizer/optuna/walkforward используют унифицированную схему: подготовка датасета с warmup → `strategy_class.run(...)` → расчет метрик/экспорт (скоринг, CSV, ZIP). 【F:info/ARCHITECTURE.md†L100-L155】【F:info/ARCHITECTURE.md†L160-L184】

## Было ⇒ стало по основным процессам
| Компонент | Было (до миграции) | Стало (после миграции) | Выигрыш |
| --- | --- | --- | --- |
| **Backtest** | Жестко зашитый S01 в `run_strategy`, UI формы статичны | Выбор стратегии в UI, конфиг грузится через API, выполнение через класс стратегии | Можно запускать любые стратегии без правки движка/UI |
| **Grid/Optuna оптимизаторы** | `_simulate_combination` с 350+ строками логики S01, кеши под S01 | Движок вызывает `strategy.run`, warmup и `strategy_id` прокинуты через конфиг; кеши отключены для MVP | Оптимизация становится стратегия-агностичной, упрощается поддержка, но временно медленнее | 
| **Walk-Forward** | Вызовы `run_strategy` и конструирование `StrategyParams` внутри окон | Подгрузка `strategy_class` из реестра, явный warmup, единый интерфейс запуска | WFA готово для любых стратегий и использует те же параметры, что UI | 
| **UI** | Одна статичная форма под S01 | Дропдаун стратегий, динамические формы из JSON, warmup поле; старые формы скрыты как fallback | UI сам подхватывает новые стратегии без ручной верстки | 

## Что осталось доделать / актуальные риски
- **S01 по-прежнему обернут поверх legacy**: `strategy.run` просто парсит словарь в `StrategyParams` и вызывает старый `run_strategy`, то есть реальный код стратегии остался в `backtest_engine.py`. Это блокирует полный отказ от старого API. 【F:src/strategies/s01_trailing_ma/strategy.py†L10-L44】【F:info/migration_prompt_5_report.md†L3-L12】
- **Оптимизаторы содержат S01-специфику**: структуры `OptimizationConfig/OptimizationResult` и `PARAMETER_MAP` жестко описывают поля S01 (все параметры MA/стопов, ни намека на универсальные словари). Добавление стратегии с другими параметрами потребует переработки этих dataclass и маппинга. 【F:src/optimizer_engine.py†L38-L164】
- **UI и фронт не тестировались**: Stage 4 и 7 отчеты отмечают, что фронт и WFA не прогонялись, поэтому возможны регрессии. 【F:info/migration_prompt_4_report.md†L8-L12】【F:info/migration_prompt_7_report.md†L8-L12】
- **Оптимизационные прогонки не выполнялись**: в Stage 6 тестов нет, только `compileall`, поэтому производительность и корректность в боевых сценариях не подтверждены. 【F:info/migration_prompt_6_report.md†L8-L13】
- **Заложенные улучшения не реализованы**: кэширование индикаторов, hot reload стратегий, валидация схемы конфигов, маркетплейс стратегий и мульти-CSV остаются планами. 【F:info/ARCHITECTURE.md†L387-L412】

## Ответы на вопросы о hardcoded параметрах
- Основная логика S01 все еще живет в `backtest_engine.run_strategy`, а класс стратегии лишь проксирует вызов — это сознательный легаси для сохранения паритета результатов на время миграции. 【F:src/strategies/s01_trailing_ma/strategy.py†L10-L44】
- В оптимизаторах заданы фиксированные поля и маппинги под S01 (MA, stop, trail параметры). Пока это не обобщено, новые стратегии с другими наборами параметров придется подгонять под эти структуры или расширять их. 【F:src/optimizer_engine.py†L38-L164】
- JSON конфиг S01 хранит полный набор параметров, но для новых стратегий планируется описывать свои параметры и маппингом не пользоваться — код нужно адаптировать, иначе он продолжит ожидать поля S01.

## Как добавлять новую стратегию (пример S_03 Reversal_v07)
1. Создать папку `src/strategies/s03_reversal/` с `config.json` (описать три параметра: тип/длина MA и счетчики закрытий; индикаторы уже есть в `get_ma`).
2. Реализовать `strategy.py` с `STRATEGY_ID/NAME/VERSION`, и `run(df, params, trade_start_idx)`:
   - Использовать `get_ma` для расчета трендового MA, счетчики закрытий по аналогии с S01, открывать/разворачивать позицию при смене сигнала (без стопов/тейков).
   - Собрать `TradeRecord` без стоп-логики, вернуть `StrategyResult` с базовыми метриками.
3. Перезапустить сервер или перезагрузить модуль: стратегия появится в дропдауне благодаря автообнаружению. 【F:info/ARCHITECTURE.md†L218-L244】【F:data/S_03 Reversal_v07 Light for Migration-2.pine†L1-L120】

## Добавление стратегии с другими индикаторами (например, RSI)
- Формула расчета индикатора должна быть в самой стратегии (в `strategy.py`), чтобы сохранить разделение: платформа не знает, какие индикаторы нужны. 【F:info/ARCHITECTURE.md†L218-L368】
- Если индикатор универсален, можно вынести его в `backtest_engine.py` как общий helper и переиспользовать в разных стратегиях; для ускорения в будущем можно задействовать `calculate_indicators()` и кэширование. 【F:info/ARCHITECTURE.md†L387-L412】
- Конфиг (`config.json`) описывает только параметры пользователя (например, период RSI, уровни), но не формулу. Код расчета остается в `strategy.py`, который читает параметры и вызывает нужный helper.

## Где остается legacy и зачем
- **backtest_engine.run_strategy** — полный бар-бай-бар код S01; обеспечивает совместимость и используется классом S01 напрямую. Нужно выносить логику в стратегию и удалить зависимость от `StrategyParams`, когда будут готовы тесты на совпадение результатов. 【F:src/strategies/s01_trailing_ma/strategy.py†L10-L44】
- **Optimization dataclass/маппинги** — отражают только поля S01, что делает оптимизацию частично зависящей от структуры S01. Требуется обобщить хранение параметров (например, словари или автогенерация из `config.json`). 【F:src/optimizer_engine.py†L38-L164】
- **UI legacy формы** — старые статические блоки скрыты, но оставлены как fallback; их можно удалить после верификации динамических форм. 【F:info/migration_prompt_4_report.md†L3-L12】
- **Walk-forward/optimizer тесты** — функционал переподключен к реестру, но без прогонов; фактически статус “прототип”. 【F:info/migration_prompt_6_report.md†L8-L13】【F:info/migration_prompt_7_report.md†L8-L12】

## Что сделать дальше
- Перенести фактическую логику S01 из `run_strategy` в `S01TrailingMA.run` и избавиться от `StrategyParams`/legacy-пути после сравнения метрик.
- Унифицировать оптимизаторы: хранить параметры как словари по `config.json`, сериализовать результаты без S01-специфичных полей и поддержать произвольные индикаторы/параметры.
- Покрыть UI/Walk-Forward/оптимизаторы интеграционными тестами, подтвердив работу динамических форм и новых стратегий.
- Реализовать кэширование индикаторов и проверку схем конфигов, чтобы ускорить бэктесты и исключить ошибки при добавлении стратегий. 【F:info/ARCHITECTURE.md†L387-L412】

