
# Migration Plan
# From Legacy S_01-Centric Project to Clean Core Architecture

**Version:** 1.4  
**Scope:** Пошаговый план миграции от текущей legacy-архитектуры к целевой структуре с 3 движками, метриками, экспортом и разделённым UI.

---

## 0. Общие Принципы

- Миграция выполняется **итеративно**, небольшими фазами.
- На каждом этапе:
  - приоритет — **сохранить поведение S_01** (и позже простой стратегии),
  - важные изменения сопровождаются прогоном регрессионных и базовых unit-тестов.
- Legacy-код удаляется **только после** успешной проверки новой реализации.
- Структуры данных (`TradeRecord`, `StrategyResult`, метрики) объявляются **внутри** соответствующих модулей (`backtest_engine.py`, `metrics.py`) и импортируются оттуда, без отдельного `types.py`.

---

## 1. Пред-фаза (-1) — Тестовая инфраструктура и pytest

**Цель:** подготовить минимальную, но удобную тестовую инфраструктуру до начала серьёзных изменений.

**Шаги:**

1. Создать папку `tests/` в корне проекта.
2. Настроить запуск тестов через `pytest` (простой `pytest.ini` или конфиг в `pyproject.toml` — по желанию).
3. Добавить хотя бы один “дышащий” тест, чтобы проверить, что инфраструктура работает:
   - например, `tests/test_sanity.py` с простым ассертами.
4. Настроить для себя привычку:
   - перед/после крупных фаз миграции запускать `pytest`,
   - использовать его как быстрый индикатор “мы всё сломали или нет”.

**Результат:** есть рабочий `pytest`, и проект готов к постепенному покрытию тестами.

---

## 2. Фаза 0 — Регрессионный Baseline для S_01

**Цель:** зафиксировать текущее поведение S_01 до любых изменений ядра.

**Шаги:**

1. Выбрать небольшой baseline-dataset (кусок реальных данных или специальный CSV) — достаточно 1–2 репрезентативных отрезков.
2. Написать `tools/generate_baseline_s01.py`, который:
   - запускает текущую (legacy) S_01 с фиксированными параметрами,
   - сохраняет:
     - основные метрики (Net Profit %, Max DD %, Total Trades и др.) в JSON,
     - список сделок в CSV в `data/baseline/`.
3. Добавить `tests/test_regression_s01.py`, который:
   - запускает legacy S_01,
   - сравнивает полученные метрики/сделки с baseline в разумных допусках:
     - Net Profit % / Max DD % — отклонения в пределах заранее заданного допуска,
     - Total Trades — допускается ±1,
     - при необходимости — выборочная проверка сделок по датам/бару.

**Результат:** “золотой” baseline S_01, к которому можно сверяться при каждом изменении ядра.

---

## 3. Фаза 1 — Разделение фронтенда на HTML / CSS / JS

**Цель:** сделать UI читаемым и поддерживаемым, не меняя его поведение.

**Шаги:**

1. Вынести стили из текущего `index.html` в `style.css`.
2. Вынести JavaScript из `index.html` в `main.js`.
3. Подключить:
   - `<link rel="stylesheet" href="static/css/style.css">` (или соответствующий путь),
   - `<script src="static/js/main.js"></script>` в `index.html`.
4. Минимально проверить работоспособность UI (ручной smoke-тест).

**Ограничение:**  
Не менять логику фронта — только физическое разделение кода.

---

## 4. Фаза 2 — Выделение ядра `src/core/` и отказ от Grid Search

**Цель:** создать явное ядро в `src/core/`, сконцентрировать все движки там и оставить только Optuna в качестве оптимизатора.

### 4.1. Перенос движков в `src/core/`

**Шаги:**

1. Создать каталог `src/core/`.
2. Переместить в `src/core/` существующие файлы:
   - `backtest_engine.py`,
   - `optuna_engine.py`,
   - `walkforward_engine.py`.
3. Обновить импорты в:
   - `server.py`,
   - `run_backtest.py`,
   - других местах, где они используются,
   чтобы модули импортировались как `from core.backtest_engine import ...` и т.п.

### 4.2. Консолидация Optuna и удаление Grid Search

Сейчас:

- Grid Search реализован в `optimizer_engine.py`;
- `optuna_engine.py` уже существует, но импортирует из `optimizer_engine.py`:
  - `OptimizationResult`,
  - `DEFAULT_SCORE_CONFIG`,
  - `PARAMETER_MAP`,
  - `_generate_numeric_sequence`,
  - `_parse_timestamp`,
  - `_run_single_combination`,
  - `calculate_score`.

**Шаги:**

1. В `optimizer_engine.py` явно выделить сущности, которые должны остаться для Optuna:
   - `OptimizationResult` (или завести отдельный тип результата для Optuna),
   - `DEFAULT_SCORE_CONFIG`,
   - `PARAMETER_MAP`,
   - `calculate_score(...)`,
   - `_generate_numeric_sequence(...)`,
   - `_parse_timestamp(...)`.
2. Перенести эти сущности в `core/optuna_engine.py` (или в небольшой вспомогательный модуль рядом с ним).
   - `OptunaConfig` уже находится в `optuna_engine.py` — его трогать не нужно.
3. Обновить `core/optuna_engine.py`, чтобы он:
   - не импортировал ничего из `optimizer_engine.py`,
   - использовал локальные определения (`OptimizationResult`, `calculate_score`, `DEFAULT_SCORE_CONFIG`, `PARAMETER_MAP` и т.п.).
4. В `src/ui/server.py`:
   - убрать ветку/режим, отвечающий за Grid Search,
   - оставить только Optuna (и WFA, если есть отдельный путь).
5. Убедиться, что все оптимизации в проекте теперь проходят через `core/optuna_engine.py` и не зависят от `optimizer_engine.py`.
6. Удалить или “заморозить” `optimizer_engine.py`:
   - либо физически удалить файл,
   - либо оставить заглушку, которая явно сообщает, что Grid Search устарел и не используется.

7. Прогнать регрессию S_01.

**Результат:** ядро сосредоточено в `src/core/`, в проекте остаётся единственный оптимизатор — `core/optuna_engine.py`, Grid Search отсутствует.

---

## 5. Фаза 3 — Пакет индикаторов `indicators/`

**Цель:** вынести индикаторы в отдельный пакет и обеспечить возможность специфичных индикаторов в стратегиях.

**Шаги:**

1. Создать `src/indicators/`:

   ```text
   src/indicators/
     __init__.py
     ma.py
     volatility.py
     oscillators.py
     volume.py
     trend.py
     misc.py
   ```

2. Найти и перенести в соответствующие файлы:
   - реализации MA (SMA, EMA, и т.п.),
   - ATR и прочие волатильностные индикаторы,
   - остальные общие индикаторы,
   которые сейчас находятся в `backtest_engine.py` или других местах.

3. В `src/strategies/base.py`:
   - реализовать fallback-механизм для индикаторов:
     - сначала ищем `indicator_<name>` в самой стратегии,
     - затем — в `custom_indicators`,
     - затем — в `indicators.*`.

4. Обновить:
   - `core/backtest_engine.py`,
   - стратегии,
   - другие модули,
   - чтобы использовать функции из `indicators/`, а не локальные реализации.

5. Прогнать регрессию S_01.

**Результат:** индикаторы не привязаны к ядру, стратегии используют общую библиотеку + могут иметь собственные специфичные индикаторы.

---

## 6. Фаза 4 — HIGH-RISK: Выделение метрик в `metrics.py` + первые unit-тесты

**Цель:** централизовать расчёт метрик, добавить базовые unit-тесты для индикаторов и метрик.

> ⚠️ **High-risk фаза №1.**  
> Любые изменения формул метрик могут сломать сравнимость результатов. Все изменения в этой фазе необходимо проверять сравнением baseline до/после.

**Шаги:**

1. Создать `core/metrics.py` с структурами:
   - `BasicMetrics`,
   - `AdvancedMetrics`,
   - (опционально) `WFAMetrics`.
2. Реализовать функции:
   - `calculate_basic(result: StrategyResult) -> BasicMetrics`,
   - `calculate_advanced(result: StrategyResult) -> AdvancedMetrics`,
   - `calculate_for_wfa(wfa_results) -> WFAMetrics` (если будет нужен отдельный формат).
3. Перенести в `metrics.py` расчёты:
   - Net Profit / %, MaxDD / %, Win Rate, Profit Factor и т.д.,
   - Sharpe, Sortino, Ulcer, Consistency, ROMAD и др.,
   которые сейчас выполняются внутри `backtest_engine.py`.
4. В `core/backtest_engine.py`:
   - убрать расчёт метрик “в лоб”,
   - при необходимости вызывать `metrics.calculate_basic(...)` перед возвратом результатов.
5. В `core/optuna_engine.py`:
   - использовать `metrics.calculate_basic/advanced` внутри целевой функции для каждого трейла.
6. В `core/walkforward_engine.py`:
   - использовать те же функции для метрик окон,
   - при необходимости — `metrics.calculate_for_wfa` для общего результата.

7. Добавить unit-тесты:
   - `tests/test_indicators.py` — проверка нескольких ключевых индикаторов (EMA, ATR и т.п.) на небольших искусственных данных.
   - `tests/test_metrics.py` — проверка `calculate_basic/advanced` на фейковом `StrategyResult` и нескольких edge-case сценариях (0 сделок, все убыточные и т.д.).

8. Прогнать:
   - регрессию S_01 до/после переноса,
   - новые unit-тесты.

**Результат:** единственный источник правды для всех метрик — `metrics.py`, а индикаторы/метрики покрыты базовыми тестами. Поведение относительно baseline остаётся тем же.

---

## 7. Фаза 5 — Централизованный экспорт в `export.py`

**Цель:** собрать экспорт CSV и отчётов в одном модуле.

**Шаги:**

1. Создать `core/export.py` с функциями:
   - `export_trades_tv(trades, path: str) -> None`,
   - `export_optuna_results(results, path: str) -> None`,
   - `export_wfa_summary(wfa_results, path: str) -> None`.

2. Перенести в `export.py`:
   - код формирования CSV-файлов для Optuna,
   - код формирования CSV-файлов для WFA,
   - экспорт сделок для TradingView (если был реализован в других местах).

3. В `core/backtest_engine.py`, `core/optuna_engine.py`, `core/walkforward_engine.py`:
   - удалить прямой CSV-форматинг,
   - заменить его вызовами функций из `export.py`.

4. Прогнать:
   - регрессию S_01,
   - unit-тесты.

**Результат:** все экспортные задачи централизованы, форматы хранятся в одном месте.

---

## 8. Фаза 6 — Простая стратегия и отладка архитектуры

**Цель:** обкатать новую архитектуру на простой стратегии до миграции сложной S_01.

**Шаги:**

1. Создать новую простую стратегию (например, простые MA-пересечения):

   ```text
   src/strategies/simple_ma/
     config.json
     strategy.py
   ```

   - `config.json` описывает параметры в текущем формате (type, default, min, max, optimize и т.д.).
   - `strategy.py` реализует класс, наследующийся от `BaseStrategy`, использующий индикаторы из `indicators/`.

2. Интегрировать `simple_ma` в:
   - UI (список стратегий),
   - `core/backtest_engine.py`,
   - `core/optuna_engine.py`,
   - `core/walkforward_engine.py`.

3. Настроить CSV-экспорт сделок для `simple_ma` и сравнить:
   - поведение и метрики против TradingView (через Trading Report Generator),
   - при необходимости — бар-в-бар.

4. Отладить архитектуру:
   - убедиться, что:
     - бэктест даёт ожидаемые результаты,
     - Optuna корректно оптимизирует параметры,
     - WFA работает с простой стратегией,
     - экспорт/метрики/индикаторы функционируют как нужно.

5. Прогнать:
   - unit-тесты,
   - регрессию S_01 (на случай, если изменения коснулись ядра),
   - sanity-check для `simple_ma`.

**Результат:** новая архитектура проверена на простой стратегии, все основные компоненты (движки, индикаторы, метрики, экспорт) отлажены без вовлечения сложной логики S_01.

---

## 9. Фаза 7 — HIGH-RISK: Миграция S_01 на новую архитектуру (через дубль)

**Цель:** перенести стратегию S_01 на новый архитектурный слой, при этом:

- **legacy-версия S_01** остаётся доступной для тестирования и сравнения,
- создаётся **дубль S_01** на новой архитектуре в отдельной папке,
- после успешного сравнения дубль становится основной версией.

> ⚠️ **High-risk фаза №2.**  
> Здесь задействованы и ядро, и сложная стратегия. Каждое изменение нужно проверять сравнением метрик и поведения (сделки, equity) относительно legacy S_01.

### 9.1. Общая идея

Сейчас:

- legacy S_01 уже живёт в `strategies/s01_trailing_ma/strategy.py` и сильно завязана на `run_strategy(...)` в `backtest_engine.py`.

План:

- оставить `strategies/s01_trailing_ma/` как есть для тестов,
- создать новую папку `strategies/s01_trailing_ma_migrated/` и реализовать там S_01_v2 по новой архитектуре.

### 9.2. Создание дубля S_01 на новой архитектуре

**Шаги:**

1. Создать:

   ```text
   src/strategies/s01_trailing_ma_migrated/
     __init__.py
     strategy.py
     config.json
   ```

2. В `config.json`:
   - перенести параметры из текущего `strategies/s01_trailing_ma/config.json`,
   - сохранить общий формат (type, default, min, max, optimize и т.д.),
   - при необходимости — убрать legacy-поля, если они больше не нужны.

3. В `strategy.py` реализовать класс `S01TrailingMAMigrated` (название на твой вкус), который:
   - наследуется от `BaseStrategy`,
   - использует индикаторы из `indicators/`,
   - реализует торговую логику внутри класса стратегии,
   - **не вызывает** `run_strategy(...)` из `backtest_engine.py`.

4. В `core/backtest_engine.py`:
   - добавить возможность запускать новую стратегию по имени/id, учитывая, что теперь есть:
     - legacy `s01_trailing_ma`,
     - новая `s01_trailing_ma_migrated`.
   - архитектура должна позволять выбрать одну из них (например, через параметр стратегии в UI/CLI).

### 9.3. Сравнение legacy S_01 и S_01_migrated

**Шаги:**

1. Использовать baseline-дataset из Фазы 0.
2. Прогнать:
   - legacy S_01 (`strategies/s01_trailing_ma`) по старому пути,
   - новую S_01_migrated (`strategies/s01_trailing_ma_migrated`) по новому пути.
3. Сравнить:
   - ключевые метрики (Net Profit %, Max DD %, Total Trades),
   - выборочно — сделки по датам/барам (через CSV-экспорт и TradingView, при необходимости).

4. Найти и устранить расхождения:
   - проверить:
     - совпадение индикаторов,
     - комиссий и размера позиции,
     - порядок исполнения ордеров,
     - off-by-one / rounding ошибки и т.п.
   - повторять, пока поведение не совпадёт в разумных пределах.

### 9.4. Переключение на новую S_01 и удаление legacy

**Шаги:**

1. После того, как новая `s01_trailing_ma_migrated` подтверждена:
   - в UI и сервере сделать её стратегией “по умолчанию” для S_01.
2. Перенести имена:
   - переименовать директорию `strategies/s01_trailing_ma/` (legacy) во что-нибудь вроде `s01_trailing_ma_legacy/` (или удалить сразу, если не нужен fallback),
   - переименовать `strategies/s01_trailing_ma_migrated/` в `strategies/s01_trailing_ma/`,
   - обновить соответствующие импорты/идентификаторы.
3. Удалить legacy S_01 и связанный код, когда он больше не нужен:
   - удалить старые файлы и классы legacy S_01,
   - вычистить S_01-специфичные хардкоды из `backtest_engine.py` и других модулей.

4. Прогнать:
   - регрессию S_01 уже через новую S_01 (бывшую migrated),
   - unit-тесты.

**Результат:** S_01 живёт в новом слое стратегий, реализована по новой архитектуре, а legacy-вариант использовался только как эталон и затем был удалён.

---

## 10. Фаза 8 — Логирование, финальная чистка и документация

**Цель:** довести проект до чистого состояния, добавить базовое логирование и обновить документацию.

**Шаги:**

1. Добавить простое логирование:
   - базовый `logging`-конфиг (например, в одном месте в ядре),
   - использование логов в трёх движках для ключевых событий (start/end прогона, ошибки).
2. В `src/cli/run_backtest.py`:
   - добавить флаг `--debug` / `--log-level`, который включает более подробное логирование,
   - UI этот флаг не трогает (логирование остаётся CLI-опцией).
3. Найти и удалить:
   - неиспользуемые функции/классы,
   - старые флаги/режимы, связанные с Grid Search и legacy S_01,
   - временный код, использовавшийся только для миграции.

4. Проверить:
   - что все ключевые сценарии проходят через:
     - `core/backtest_engine.py`,
     - `core/optuna_engine.py`,
     - `core/walkforward_engine.py`,
     - `core/metrics.py`,
     - `core/export.py`,
     - `indicators/`,
     - `strategies/`.
   - что нет прямых вызовов legacy-модулей.

5. Обновить документацию:
   - `PROJECT_TARGET_ARCHITECTURE.md` (актуальное состояние архитектуры),
   - `PROJECT_STRUCTURE.md` (структура каталогов),
   - краткий guide “как добавить новую стратегию”,
   - описание формата `config.json` для стратегий.

**Результат:** проект в чистом, понятном состоянии, архитектура соответствует целевой схеме, документация отражает текущую реализацию, логирование помогает при отладке.

---

## 11. Вне текущего scope (на будущее)

Следующие шаги можно рассматривать после завершения миграции:

- Pine-friendly слой и/или TV-like API (StrategySettings, Portfolio, StrategyAPI).
- Превращение проекта в полноценный Python-пакет (если это когда-нибудь понадобится).
- Глубокий рефакторинг UI (новые графики, улучшенная визуализация WFA и т.д.).
- Расширение набора стратегий и индикаторов на базе новой архитектуры.
