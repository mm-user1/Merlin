# План переноса индикаторов из движка в стратегии

## Цели и ограничения
- Убрать зависимость движков (`backtest_engine.py`, оптимизаторы) от конкретных индикаторов, чтобы каждая стратегия была самодостаточной, как в PineScript.
- Сохранить совместимость: S01 должна выдавать те же метрики, что и текущий `run_strategy`, до/после переноса.
- Не ломать API реестра стратегий: запуск по `strategy_id`, warmup и параметры остаются как есть.

## Текущее состояние
- Индикаторы (MA, ATR, VWAP, ALMA, KAMA и др.) реализованы в `backtest_engine.py`, а стратегия S01 только проксирует вызов в `run_strategy`, не вычисляя ничего сама. 【F:src/backtest_engine.py†L56-L169】【F:src/strategies/s01_trailing_ma/strategy.py†L10-L44】
- Базовый класс имеет заглушку `calculate_indicators`, но движки её не используют; расчёты полностью зашиты в движок. 【F:src/strategies/base.py†L1-L49】

## Целевая архитектура
- **Стратегии сами считают индикаторы.** В `strategy.py` каждой стратегии появляются локальные хелперы (MA/ATR/и т.п.) и/или метод `calculate_indicators`, который возвращает готовые серии.
- **Движки не знают про индикаторы.** `backtest_engine` управляет данными, риск-метриками и порядком обхода баров, но обращается к методам стратегии (`calculate_indicators` или явные хелперы) вместо внутренних `get_ma/atr`.
- **Оптимизаторы передают только параметры.** Параметры берутся из `config.json` стратегии, индикаторы не перечисляются в движке.

## Пошаговый перенос
1. **Расширить контракт базовой стратегии**
   - Обновить докстринг/сигнатуру `calculate_indicators(df, params)` так, чтобы движки могли запросить предвычисления (для кеша). 
   - Добавить опциональный метод `get_indicator(name, *args, **kwargs)` или документировать, что стратегия публикует хелперы напрямую.

2. **Перенести индикаторы S01 в её `strategy.py`**
   - Скопировать из `backtest_engine.py` все функции MA/ATR/VWAP/ALMA/KAMA/T3/HMA/WMA/DEMA/TMA в `strategies/s01_trailing_ma/strategy.py` как приватные.
   - Внутри `run` рассчитать нужные серии (основной MA, trail MAs, ATR, lowest/highest для трейлинга) и использовать их вместо вызовов движка.
   - Оставить `StrategyParams.from_dict` только для парсинга, но расчёты должны опираться на локальные индикаторы.

3. **Сузить обязанности `backtest_engine.py`**
   - Удалить/отключить вызовы внутренних индикаторов; вместо этого двигать ответственность в стратегию. 
   - Сосредоточить модуль на: чтении CSV, обеспечении warmup, подсчёте метрик (Sharpe, PF, RoMaD), агрегировании `TradeRecord`/`StrategyResult`.

4. **Подготовить путь для новых стратегий**
   - Обновить движки (`optimizer_engine.py`, `optuna_engine.py`, `walkforward_engine.py`) так, чтобы они не ожидали наличия `get_ma/atr` в движке; стратегии сами готовят данные.
   - Для кеширования индикаторов при оптимизации использовать `calculate_indicators` стратегии: кеш ключом `(strategy_id, params_hash)` или `(indicator_name, params)` внутри воркеров.

5. **Верификация совместимости**
   - До и после переноса прогнать S01 на фиксированном CSV с одинаковыми параметрами; сравнить метрики `net_profit_pct`, `max_drawdown_pct`, `total_trades`, Sharpe, PF, RoMaD.
   - Если расхождений нет — удалить дублирующие индикаторные хелперы из `backtest_engine.py` или пометить как общие утилиты (не вызываемые автоматически).

6. **Документация и примеры**
   - Обновить `ARCHITECTURE.md` и README раздел «Как добавлять стратегию» с указанием, что формулы индикаторов пишутся внутри `strategy.py`.
   - Добавить шаблон/пример стратегии, где индикаторы определены локально (в т.ч. для новых индикаторов вроде RSI), чтобы разработчики следовали новой схеме.

## Особые случаи
- **Новые индикаторы (например, RSI)**: формула размещается в `strategy.py` конкретной стратегии. Если индикатор станет общим, можно вынести в отдельный модуль `strategies/indicators.py`, но движок его не должен импортировать автоматически.
- **Оптимизационные кеши**: кешировать можно только то, что выдаёт стратегия (MA/ATR/RSI), без жёстких списков в движке.
- **Совместимость UI**: параметры индикаторов описываются только в `config.json` стратегии; сервер берёт эти поля как есть и не хранит список индикаторов.

## Риски и контрольные точки
- Вероятны расхождения метрик из-за различий в заполнении NaN или округлении при переносе; нужно тестирование на реальных CSV.
- Производительность может просесть без кешей; после переноса добавить вычисление индикаторов один раз и передавать серии в симуляцию.
- До завершения шага 5 оставляем легаси функции в `backtest_engine.py` под флагом/комментарием, чтобы быстро сравнить результаты.
