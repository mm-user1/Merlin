# Оптимизаторы Optuna/Grid и несовместимость snake_case ↔ camelCase

## Контекст
- После перехода на модульную систему стратегий движок автоматически обнаруживает стратегии по `config.json` + `strategy.py` и предоставляет их через реестр (`strategies/__init__.py`).【F:src/strategies/__init__.py†L17-L155】
- Стратегии принимают параметры в camelCase: `StrategyParams.from_dict()` парсит ключи вроде `maType`, `trailLongType`, `riskPerTrade` и т.д.【F:src/backtest_engine.py†L168-L213】

## Что происходит сейчас
- Grid/Optuna используют жёстко заданный `PARAMETER_MAP`, где фронтовые camelCase имена мапятся на внутренние snake_case (`ma_length`, `stop_long_atr` и пр.).【F:src/optimizer_engine.py†L143-L203】【F:src/optuna_engine.py†L68-L132】
- Перед вызовом стратегии `_run_single_combination` конвертирует только известные snake_case ключи обратно в camelCase через статический `INTERNAL_TO_FRONTEND_MAP`. Всё, что не попало в карту, уходит в стратегию как snake_case и там игнорируется, что возвращает параметры к значениям по умолчанию.【F:src/optimizer_engine.py†L165-L333】
- Текущая “заплата” добавляет глобальные параметры и MA-типы в карту, но она завязана на конкретные поля S01 и не покрывает новые стратегии или новые параметры в существующей стратегии.【F:src/optimizer_engine.py†L165-L333】【F:src/optuna_engine.py†L266-L283】

## Корень проблемы
1. Оптимизаторы держат собственное внутреннее представление snake_case, тогда как стратегии (и их схемы в `config.json`) живут в camelCase. Любые новые параметры придётся вручную добавлять в обе карты.
2. Архитектура мульти-стратегий уже умеет находить новые стратегии, но оптимизаторы всё ещё «зашиты» под S01: набор параметров, генерация грида/спейса и конверсия имён не опираются на метаданные стратегии.

## Варианты решения
### 1) Единый camelCase-пайплайн, построенный на конфиге стратегии (рекомендовано)
- Генерировать грид и Optuna search space из `parameters` выбранной стратегии (camelCase), не вводя snake_case вообще.
- В `_run_single_combination` передавать стратегию ровно тот payload, что собран из конфига, без конверсии; внутренние структуры результата могут остаться snake_case, потому что они относятся к таблице результатов, а не к входным параметрам.
- Для обратной совместимости CSV/статистики можно хранить человеко-читаемые столбцы отдельно от параметров или добавить опциональный `internalName` в JSON (если нужен alias для имени столбца), но базовый поток остаётся camelCase.
- Плюсы: стратегия-агностичность, отсутствие ручных карт, автоматическое покрытие новых стратегий/параметров, единая точка правды — конфиг стратегии.
- Минусы: потребуется рефакторинг генерации грида/спейса и валидации, а также миграция существующих тестов под camelCase входы.

### 2) Автогенерация двунаправленной карты имён из конфига стратегии
- При загрузке стратегии строить `frontend → internal` и `internal → frontend` автоматически: например, задавать `internalName` в параметрах JSON (по умолчанию совпадает с camelCase). Грид и Optuna работают с `internalName`, а перед вызовом стратегии выполняется авто-конверсия по карте.
- Плюсы: сохраняет текущую snake_case математику внутри оптимизаторов и таблиц результатов, но делает её декларативной и расширяемой для новых стратегий.
- Минусы: остаётся дублирование имён (camel vs internal), нужно синхронизировать схемы JSON, сложнее отлаживать из-за двойной системы имён.

### 3) Допустить оба формата на уровне стратегий
- На уровне `StrategyParams.from_dict()` (и аналогов в других стратегиях) принимать и camelCase, и snake_case ключи, приводя их к одному виду.
- Плюсы: минимальный риск сломать оптимизаторы, быстрый hotfix.
- Минусы: каждая стратегия должна реализовывать подобную нормализацию; не убирает дублирование в оптимизаторах, а лишь маскирует проблему, растёт технический долг.

## Оценка «переписать движки в camelCase»
- Полный переход оптимизаторов на camelCase (вариант 1) совместим с общей кодовой базой: стратегии уже ожидают camelCase, конфиги его задают, фронт использует его же.
- Потребуются изменения в генерации грида/Optuna-спейса (работа напрямую с camelCase), валидации входов и, возможно, в именовании столбцов результатов/CSV, если они должны остаться в snake_case. Это однократная миграция, после которой добавление параметров/стратегий будет декларативным (по конфигу) и без ручных карт.

## Рекомендуемый путь
- Реализовать вариант 1: сделать конфиг стратегии единственным источником истины, держать входные параметры в camelCase от формы до `strategy.run`, а генерацию грида/спейса строить из конфигурации стратегии. В случае необходимости оставить человеко-читаемые названия столбцов — вынести их в отдельную схему, не смешивая с параметрами.
- Если нужно краткосрочное улучшение без большого рефактора — вариант 2 как промежуточный шаг: добавить `internalName` в JSON, строить карты автоматически и удалить ручные словари `PARAMETER_MAP`/`INTERNAL_TO_FRONTEND_MAP`.
