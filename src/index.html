<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Strategy Backtester &amp; Optimizer</title>
    <link rel="stylesheet" href="/static/css/style.css" />
</head>
<body>
  <div class="pane">
    <div class="split">
      <div class="frame">
        <div class="window backtester-window">
          <div class="title-bar">
            <h2>Backtester</h2>
          </div>
          <div class="content">
            <form id="backtestForm">
              <!-- ============================================ -->
              <!-- STRATEGY SELECTOR -->
              <!-- ============================================ -->
              <div
                class="strategy-selector-section"
                style="margin-bottom: 30px; padding: 20px; background-color: #f0f8ff; border: 2px solid #4a90e2; border-radius: 8px;"
              >
                <h2 style="margin-top: 0; color: #4a90e2;">üìä Select Strategy</h2>

                <div class="form-group">
                  <label style="font-weight: bold;">Strategy:</label>
                  <select
                    id="strategySelect"
                    onchange="handleStrategyChange()"
                    style="padding: 8px; font-size: 14px; min-width: 300px;"
                  >
                    <option value="">Loading strategies...</option>
                  </select>
                </div>

                <div
                  id="strategyInfo"
                  style="margin-top: 15px; padding: 15px; background-color: white; border-radius: 5px; display: none;"
                >
                  <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; font-size: 14px;">
                    <strong>Name:</strong> <span id="strategyName"></span>
                    <strong>Version:</strong> <span id="strategyVersion"></span>
                    <strong>Description:</strong> <span id="strategyDescription"></span>
                    <strong>Parameters:</strong> <span id="strategyParamCount"></span>
                  </div>
                </div>
              </div>

              <div class="section">
                <div class="form-group">
                  <div class="checkbox-group">
                    <input type="checkbox" id="dateFilter" />
                    <label for="dateFilter">Date Filter</label>
                  </div>
                  <div class="checkbox-group">
                    <input type="checkbox" id="backtester" />
                    <label for="backtester">Backtester</label>
                  </div>
                </div>

                <div class="form-group">
                  <label for="startDate">Start Date</label>
                  <input type="text" id="startDate" class="date-input" autocomplete="off" />
                  <button type="button" class="calendar-btn" tabindex="-1">üìÖ</button>
                  <input type="text" id="startTime" class="small-input" autocomplete="off" />
                </div>

                <div class="form-group">
                  <label for="endDate">End Date</label>
                  <input type="text" id="endDate" class="date-input" autocomplete="off" />
                  <button type="button" class="calendar-btn" tabindex="-1">üìÖ</button>
                  <input type="text" id="endTime" class="small-input" autocomplete="off" />
                </div>

                <!-- Add after End Time input -->
                <div class="form-group">
                  <label>Warmup Bars:</label>
                  <input
                    type="number"
                    id="warmupBars"
                    name="warmupBars"
                    value="1000"
                    min="100"
                    max="5000"
                    step="100"
                    style="width: 120px;"
                  />
                  <span style="margin-left: 10px; font-size: 12px; color: #666;">
                    (Bars before Start Date for indicator calculation. Recommended: 1000-2000)
                  </span>
                </div>

                <div class="form-group vertical">
                  <label for="csvFile">CSV —Ñ–∞–π–ª (OHLCV)</label>
                  <input type="file" id="csvFile" accept=".csv" multiple />
                  <div id="selectedFilesWrapper" class="selected-files">
                    <div class="selected-files-title">–í—ã–±—Ä–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã</div>
                    <ul id="selectedFilesList" class="selected-files-list"></ul>
                  </div>
                </div>

                <div class="form-group">
                  <div class="filter-group" id="exportTradesFilterGroup">
                    <div class="checkbox-group">
                      <input type="checkbox" id="wfExportTrades" />
                      <label for="wfExportTrades">Export Trades</label>
                    </div>
                    <div class="filter-input-group">
                      <label for="wfExportTopK">Top</label>
                      <input
                        type="number"
                        id="wfExportTopK"
                        min="1"
                        max="100"
                        step="1"
                        value="10"
                      />
                    </div>
                  </div>
                </div>
              </div>

              <div class="section">
                <div class="section-title">Optimization Filters</div>
                <div class="form-group">
                  <div class="filter-group" id="minProfitFilterGroup">
                    <div class="checkbox-group">
                      <input type="checkbox" id="minProfitFilter" />
                      <label for="minProfitFilter">Net Profit Filter</label>
                    </div>
                    <div class="filter-input-group">
                      <label for="minProfitThreshold">Min %</label>
                      <input
                        type="number"
                        id="minProfitThreshold"
                        min="0"
                        max="99000"
                        step="1.0"
                        value="0"
                        disabled
                      />
                    </div>
                  </div>
                </div>

                <div class="form-group">
                  <div class="filter-group" id="scoreFilterGroup">
                    <div class="checkbox-group">
                      <input type="checkbox" id="scoreFilter" />
                      <label for="scoreFilter">Score Filter</label>
                    </div>
                    <div class="filter-input-group">
                      <label for="scoreThreshold">Min Score</label>
                      <input
                        type="number"
                        id="scoreThreshold"
                        min="0"
                        max="100"
                        step="0.1"
                        value="60"
                        disabled
                      />
                    </div>
                    <button type="button" class="secondary" id="scoreConfigBtn" style="margin-left: 10px;">‚öôÔ∏è Configure</button>
                  </div>
                </div>

                <div class="collapsible" id="scoreConfigCollapsible">
                  <div class="collapsible-header">
                    <span class="collapsible-icon">‚ñº</span>
                    <span class="section-title" style="margin: 0; border: none;">Score Formula</span>
                  </div>
                  <div class="collapsible-content">
                    <div style="font-size: 12px; color: #5a5a5a; margin-bottom: 10px;">
                      Adjust weights (0.00-1.00) for each metric. Disabled metrics are excluded from Score.
                    </div>

                    <div class="score-formula-params">
                      <div class="score-metric-row">
                        <input type="checkbox" id="metric-romad" checked />
                        <label for="metric-romad" style="min-width: 140px;">RoMaD</label>
                        <input type="number" id="weight-romad" step="0.05" min="0" max="1" value="0.25" style="width: 70px;" />
                        <span style="font-size: 11px; color: #777;">Profit / |MaxDD|</span>
                      </div>

                      <div class="score-metric-row">
                        <input type="checkbox" id="metric-sharpe" checked />
                        <label for="metric-sharpe" style="min-width: 140px;">Sharpe Ratio</label>
                        <input type="number" id="weight-sharpe" step="0.05" min="0" max="1" value="0.20" style="width: 70px;" />
                        <span style="font-size: 11px; color: #777;">Risk-adjusted return</span>
                      </div>

                      <div class="score-metric-row">
                        <input type="checkbox" id="metric-pf" checked />
                        <label for="metric-pf" style="min-width: 140px;">Profit Factor</label>
                        <input type="number" id="weight-pf" step="0.05" min="0" max="1" value="0.20" style="width: 70px;" />
                        <span style="font-size: 11px; color: #777;">Gross Win / Loss</span>
                      </div>

                      <div class="score-metric-row">
                        <input type="checkbox" id="metric-ulcer" checked />
                        <label for="metric-ulcer" style="min-width: 140px;">Ulcer Index</label>
                        <input type="number" id="weight-ulcer" step="0.05" min="0" max="1" value="0.15" style="width: 70px;" />
                        <input type="checkbox" id="invert-ulcer" checked style="margin-left: 8px;" />
                        <label for="invert-ulcer" style="font-size: 11px; min-width: auto;">Invert</label>
                      </div>

                      <div class="score-metric-row">
                        <input type="checkbox" id="metric-recovery" checked />
                        <label for="metric-recovery" style="min-width: 140px;">Recovery Factor</label>
                        <input type="number" id="weight-recovery" step="0.05" min="0" max="1" value="0.10" style="width: 70px;" />
                      </div>

                      <div class="score-metric-row">
                        <input type="checkbox" id="metric-consistency" checked />
                        <label for="metric-consistency" style="min-width: 140px;">Consistency Score</label>
                        <input type="number" id="weight-consistency" step="0.05" min="0" max="1" value="0.10" style="width: 70px;" />
                        <span style="font-size: 11px; color: #777;">Profitable months %</span>
                      </div>
                    </div>

                    <div style="margin-top: 12px; padding: 8px; background: #fff; border: 1px solid #ccc; border-radius: 3px; font-size: 12px;">
                      <strong>Formula Preview:</strong> <span id="formulaPreview">Calculating...</span>
                    </div>

                    <button type="button" class="secondary" id="resetScoreBtn" style="margin-top: 10px;">Reset to Defaults</button>
                  </div>
                </div>
              </div>

              <!-- ============================================ -->
              <!-- DYNAMIC STRATEGY PARAMETERS -->
              <!-- ============================================ -->
              <div id="dynamicParameterForms" style="margin-top: 30px;">
                <h2>Strategy Parameters</h2>

                <!-- Backtest Parameters Container -->
                <div id="backtestParamsContainer" class="params-section">
                  <h3>Backtest Parameters</h3>
                  <div id="backtestParamsContent">
                    <!-- Generated forms will appear here -->
                  </div>
                </div>
              </div>

              <!-- Hide old hardcoded forms (keep for fallback) -->
              <div id="legacyForms" style="display: none;">
              <div class="section">
                <div class="form-group with-ma">
                  <label>T MA Type</label>
                  <div class="ma-selector" data-group="trend">
                    <div class="ma-row">
                      <div class="ma-option">
                        <input type="checkbox" id="trend-all" data-group="trend" data-type="ALL" />
                        <label for="trend-all">ALL</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-ema" data-group="trend" data-type="EMA" />
                        <label for="trend-ema">EMA</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-sma" data-group="trend" data-type="SMA" />
                        <label for="trend-sma">SMA</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-hma" data-group="trend" data-type="HMA" />
                        <label for="trend-hma">HMA</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-wma" data-group="trend" data-type="WMA" />
                        <label for="trend-wma">WMA</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-alma" data-group="trend" data-type="ALMA" />
                        <label for="trend-alma">ALMA</label>
                      </div>
                    </div>
                    <div class="ma-row">
                      <div class="ma-option">
                        <input type="checkbox" id="trend-kama" data-group="trend" data-type="KAMA" />
                        <label for="trend-kama">KAMA</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-tma" data-group="trend" data-type="TMA" />
                        <label for="trend-tma">TMA</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-t3" data-group="trend" data-type="T3" />
                        <label for="trend-t3">T3</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-dema" data-group="trend" data-type="DEMA" />
                        <label for="trend-dema">DEMA</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-vwma" data-group="trend" data-type="VWMA" />
                        <label for="trend-vwma">VWMA</label>
                      </div>
                      <div class="ma-option">
                        <input type="checkbox" id="trend-vwap" data-group="trend" data-type="VWAP" />
                        <label for="trend-vwap">VWAP</label>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="form-group">
                  <label for="maLength">Length</label>
                  <input type="number" id="maLength" min="0" />
                </div>

                <div class="form-group">
                  <label for="closeCountLong">Close Count Long</label>
                  <input type="number" id="closeCountLong" min="0" />
                  <label for="closeCountShort">Close Count Short</label>
                  <input type="number" id="closeCountShort" min="0" />
                </div>
              </div>

              <div class="collapsible open">
                <div class="collapsible-header">
                  <span class="collapsible-icon">‚ñº</span>
                  <span class="section-title" style="margin: 0; border: none;">STOPS AND FILTERS</span>
                </div>
                <div class="collapsible-content">
                  <div class="param-group">
                    <label for="stopLongX">Stop Long X</label>
                    <input type="number" id="stopLongX" step="0.1" min="0" />
                    <label for="stopLongRR">RR</label>
                    <input type="number" id="stopLongRR" step="0.1" min="0" />
                    <label for="stopLongLP">LP</label>
                    <input type="number" id="stopLongLP" min="1" />
                  </div>

                  <div class="param-group">
                    <label for="stopShortX">Stop Short X</label>
                    <input type="number" id="stopShortX" step="0.1" min="0" />
                    <label for="stopShortRR">RR</label>
                    <input type="number" id="stopShortRR" step="0.1" min="0" />
                    <label for="stopShortLP">LP</label>
                    <input type="number" id="stopShortLP" min="1" />
                  </div>

                  <div class="param-group">
                    <label for="stopLongMaxPct">L Stop Max %</label>
                    <input type="number" id="stopLongMaxPct" step="0.1" min="0" />
                    <label for="stopShortMaxPct">S Stop Max %</label>
                    <input type="number" id="stopShortMaxPct" step="0.1" min="0" />
                  </div>

                  <div class="param-group">
                    <label for="stopLongMaxDays">L Stop Max D</label>
                    <input type="number" id="stopLongMaxDays" min="0" />
                    <label for="stopShortMaxDays">S Stop Max D</label>
                    <input type="number" id="stopShortMaxDays" min="0" />
                  </div>
                </div>
              </div>

              <div class="collapsible open">
                <div class="collapsible-header">
                  <span class="collapsible-icon">‚ñº</span>
                  <span class="section-title" style="margin: 0; border: none;">TRAILING STOPS</span>
                </div>
                <div class="collapsible-content">
                  <div class="param-group">
                    <label for="trailRRLong">Trail RR Long</label>
                    <input type="number" id="trailRRLong" step="0.1" min="0" />
                    <label for="trailRRShort">Trail RR Short</label>
                    <input type="number" id="trailRRShort" step="0.1" min="0" />
                  </div>

                  <div class="param-group" style="flex-direction: column; align-items: flex-start;">
                    <label>Trail MA Long</label>
                    <div class="ma-selector" data-group="trailLong">
                      <div class="ma-row">
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-all" data-group="trailLong" data-type="ALL" />
                          <label for="trailLong-all">ALL</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-ema" data-group="trailLong" data-type="EMA" />
                          <label for="trailLong-ema">EMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-sma" data-group="trailLong" data-type="SMA" />
                          <label for="trailLong-sma">SMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-hma" data-group="trailLong" data-type="HMA" />
                          <label for="trailLong-hma">HMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-wma" data-group="trailLong" data-type="WMA" />
                          <label for="trailLong-wma">WMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-alma" data-group="trailLong" data-type="ALMA" />
                          <label for="trailLong-alma">ALMA</label>
                        </div>
                      </div>
                      <div class="ma-row">
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-kama" data-group="trailLong" data-type="KAMA" />
                          <label for="trailLong-kama">KAMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-tma" data-group="trailLong" data-type="TMA" />
                          <label for="trailLong-tma">TMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-t3" data-group="trailLong" data-type="T3" />
                          <label for="trailLong-t3">T3</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-dema" data-group="trailLong" data-type="DEMA" />
                          <label for="trailLong-dema">DEMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-vwma" data-group="trailLong" data-type="VWMA" />
                          <label for="trailLong-vwma">VWMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailLong-vwap" data-group="trailLong" data-type="VWAP" />
                          <label for="trailLong-vwap">VWAP</label>
                        </div>
                      </div>
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 8px; align-items: center;">
                      <label for="trailLongLength">Length</label>
                      <input type="number" id="trailLongLength" min="0" />
                      <label for="trailLongOffset">Offset</label>
                      <input type="number" id="trailLongOffset" step="0.1" />
                      <label style="display: flex; align-items: center; gap: 4px;">
                        <input type="checkbox" id="trailLock" />
                        <span title="Pair Trail MA Long & Short by the same MA type during optimization">Lock</span>
                      </label>
                    </div>
                  </div>

                  <div class="param-group" style="flex-direction: column; align-items: flex-start;">
                    <label>Trail MA Short</label>
                    <div class="ma-selector" data-group="trailShort">
                      <div class="ma-row">
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-all" data-group="trailShort" data-type="ALL" />
                          <label for="trailShort-all">ALL</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-ema" data-group="trailShort" data-type="EMA" />
                          <label for="trailShort-ema">EMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-sma" data-group="trailShort" data-type="SMA" />
                          <label for="trailShort-sma">SMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-hma" data-group="trailShort" data-type="HMA" />
                          <label for="trailShort-hma">HMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-wma" data-group="trailShort" data-type="WMA" />
                          <label for="trailShort-wma">WMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-alma" data-group="trailShort" data-type="ALMA" />
                          <label for="trailShort-alma">ALMA</label>
                        </div>
                      </div>
                      <div class="ma-row">
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-kama" data-group="trailShort" data-type="KAMA" />
                          <label for="trailShort-kama">KAMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-tma" data-group="trailShort" data-type="TMA" />
                          <label for="trailShort-tma">TMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-t3" data-group="trailShort" data-type="T3" />
                          <label for="trailShort-t3">T3</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-dema" data-group="trailShort" data-type="DEMA" />
                          <label for="trailShort-dema">DEMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-vwma" data-group="trailShort" data-type="VWMA" />
                          <label for="trailShort-vwma">VWMA</label>
                        </div>
                        <div class="ma-option">
                          <input type="checkbox" id="trailShort-vwap" data-group="trailShort" data-type="VWAP" />
                          <label for="trailShort-vwap">VWAP</label>
                        </div>
                      </div>
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 8px; align-items: center;">
                      <label for="trailShortLength">Length</label>
                      <input type="number" id="trailShortLength" min="0" />
                      <label for="trailShortOffset">Offset</label>
                      <input type="number" id="trailShortOffset" step="0.1" />
                    </div>
                  </div>
                </div>
              </div>

              <div class="section">
                <div class="form-group">
                  <label for="riskPerTrade">Risk Per Trade</label>
                  <input type="number" id="riskPerTrade" step="0.01" min="0" />
                  <label for="contractSize">Contract Size</label>
                  <input type="number" id="contractSize" step="0.01" min="0" />
                </div>
              </div>

              </div>

              <div class="section">
                <div class="section-title">Results</div>
                <div id="results" class="results-area">–ù–∞–∂–º–∏—Ç–µ ¬´Run¬ª –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –±—ç–∫—Ç–µ—Å—Ç–∞‚Ä¶</div>
                <div id="error" class="error" role="alert" style="display:none;"></div>
              </div>

              <div class="button-group">
                <div class="preset-dropdown" id="presetDropdown">
                  <button type="button" class="secondary preset-toggle" id="presetToggle">Presets</button>
                  <div class="preset-menu" id="presetMenu" role="menu" aria-hidden="true">
                    <button type="button" class="preset-action" data-action="apply-defaults" role="menuitem">Apply defaults</button>
                    <button type="button" class="preset-action" data-action="save-as" role="menuitem">Save as‚Ä¶</button>
                    <div class="preset-separator"></div>
                    <div class="preset-empty" id="presetEmpty">No saved presets yet</div>
                    <div class="preset-list" id="presetList"></div>
                    <div class="preset-separator"></div>
                    <button type="button" class="preset-action" data-action="save-defaults" role="menuitem">Save as defaults</button>
                    <button type="button" class="preset-action" data-action="import" role="menuitem">Import from CSV‚Ä¶</button>
                    <input type="file" id="presetImportInput" class="preset-import-input" accept=".csv" />
                  </div>
                </div>
                <div style="display: flex; gap: 10px;">
                  <button type="button" class="secondary" id="cancelBtn">Cancel</button>
                  <button type="submit" id="runBtn">Run</button>
                </div>
              </div>
            </form>
          </div>
        </div>
      </div>

      <div class="frame">
        <div class="window optimizer-window">
          <div class="title-bar">
            <h2>Optimizer Parameters</h2>
          </div>
          <div class="content">
            <div class="left-panel">
              <form id="optimizerForm">
                <div class="info-panel">
                  <div class="info-row">
                    <label for="workerProcesses">Worker processes:</label>
                    <input
                      type="number"
                      id="workerProcesses"
                      name="workerProcesses"
                      min="1"
                      max="32"
                      value="6"
                    />
                  </div>
                </div>

                <div id="optunaSettings" class="collapsible open">
                  <div class="collapsible-header">
                    <span class="collapsible-icon">‚ñº</span>
                    <span class="section-title" style="margin: 0; border: none;">OPTUNA SETTINGS</span>
                  </div>
                  <div class="collapsible-content">
                    <div class="form-group">
                      <label for="optunaTarget">Optimization target:</label>
                      <select id="optunaTarget" style="width: 220px;">
                        <option value="score" selected>Composite Score (recommended)</option>
                        <option value="net_profit">Net Profit %</option>
                        <option value="romad">RoMaD</option>
                        <option value="sharpe">Sharpe Ratio</option>
                        <option value="max_drawdown">Max Drawdown % (minimize)</option>
                      </select>
                    </div>

                    <div class="form-group" style="flex-direction: column; align-items: flex-start; gap: 8px;">
                      <label>Optimization budget:</label>

                      <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="radio" id="budgetTrials" name="budgetMode" value="trials" checked />
                        <label for="budgetTrials" style="min-width: auto;">Number of trials:</label>
                        <input type="number" id="optunaTrials" min="10" max="10000" value="500" style="width: 80px;" />
                      </div>

                      <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="radio" id="budgetTime" name="budgetMode" value="time" />
                        <label for="budgetTime" style="min-width: auto;">Time limit:</label>
                        <input type="number" id="optunaTimeLimit" min="1" max="1440" value="60" style="width: 80px;" />
                        <span style="font-size: 13px; color: #5a5a5a;">minutes</span>
                      </div>

                      <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="radio" id="budgetConvergence" name="budgetMode" value="convergence" />
                        <label for="budgetConvergence" style="min-width: auto;">No improvement for:</label>
                        <input type="number" id="optunaConvergence" min="10" max="500" value="50" style="width: 80px;" />
                        <span style="font-size: 13px; color: #5a5a5a;">trials</span>
                      </div>
                    </div>

                    <div class="form-group">
                      <div class="checkbox-group">
                        <input type="checkbox" id="optunaPruning" checked />
                        <label for="optunaPruning">Enable pruning (stop bad trials early)</label>
                      </div>
                    </div>

                    <div
                      style="padding: 10px; background: #e0f3ff; border: 1px solid #90caf9; border-radius: 3px; margin-top: 10px;"
                    >
                      <div style="font-size: 12px; color: #1565c0;">
                        ‚ÑπÔ∏è When using "Composite Score" target, weights are taken from
                        <a href="#" id="linkToScoreConfig" style="color: #0d47a1; text-decoration: underline;">Score Filter configuration</a>
                        in the left panel.
                      </div>
                    </div>

                    <div class="collapsible" style="margin-top: 15px;">
                      <div class="collapsible-header">
                        <span class="collapsible-icon">‚ñº</span>
                        <span class="section-title" style="margin: 0; border: none;">Advanced Settings</span>
                      </div>
                      <div class="collapsible-content">
                        <div class="form-group">
                          <label for="optunaSampler">Sampler:</label>
                          <select id="optunaSampler" style="width: 200px;">
                            <option value="tpe" selected>TPE (recommended)</option>
                            <option value="random">Random</option>
                          </select>
                        </div>

                        <div class="form-group">
                          <label for="optunaPruner">Pruner:</label>
                          <select id="optunaPruner" style="width: 200px;">
                            <option value="median" selected>Median</option>
                            <option value="percentile">Percentile (25%)</option>
                            <option value="patient">Patient (stable)</option>
                            <option value="none">None</option>
                          </select>
                        </div>

                        <div class="form-group">
                          <label for="optunaWarmupTrials">Initial random trials:</label>
                          <input type="number" id="optunaWarmupTrials" min="0" max="50000" value="20" style="width: 80px;" />
                        </div>

                        <div class="form-group">
                          <div class="checkbox-group">
                            <input type="checkbox" id="optunaSaveStudy" />
                            <label for="optunaSaveStudy">Save study database (optuna_study.db)</label>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="section">
                  <div id="optimizerParamsContainer" class="optimizer-params-container">
                    <!-- Parameters will be generated dynamically here -->
                  </div>
                </div>

                <div
                  id="maTypeSelectorContainer"
                  class="section"
                  style="display: none; margin-top: 24px;"
                >
                  <div
                    class="card"
                    style="background-color: #f9f9f9; padding: 20px; border-radius: 8px; border: 1px solid #dfe3e8;"
                  >
                    <h3 style="margin-top: 0; color: #4a90e2;">MA Type Selection (for Optimization)</h3>
                    <p style="font-size: 13px; color: #666; margin-bottom: 20px;">
                      Select which Moving Average types to test during optimization. The optimizer will create
                      combinations of these types.
                    </p>

                    <div class="ma-type-section">
                      <h4 style="color: #4a90e2; font-size: 14px; margin-bottom: 10px;">Trend MA Types</h4>
                      <div class="checkbox-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 8px;">
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="ALL" />
                          <span>All</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="SMA" />
                          <span>SMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="EMA" />
                          <span>EMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="HMA" checked />
                          <span>HMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="ALMA" />
                          <span>ALMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="KAMA" />
                          <span>KAMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="WMA" />
                          <span>WMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="TMA" />
                          <span>TMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="T3" />
                          <span>T3</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="DEMA" />
                          <span>DEMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="VWMA" />
                          <span>VWMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trend" data-type="VWAP" />
                          <span>VWAP</span>
                        </label>
                      </div>
                    </div>

                    <div class="ma-type-section" style="margin-top: 20px;">
                      <h4 style="color: #4a90e2; font-size: 14px; margin-bottom: 10px;">Trail Long MA Types</h4>
                      <div class="checkbox-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 8px;">
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="ALL" />
                          <span>All</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="SMA" />
                          <span>SMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="EMA" />
                          <span>EMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="HMA" checked />
                          <span>HMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="ALMA" />
                          <span>ALMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="KAMA" />
                          <span>KAMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="WMA" />
                          <span>WMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="TMA" />
                          <span>TMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="T3" />
                          <span>T3</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="DEMA" />
                          <span>DEMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="VWMA" />
                          <span>VWMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailLong" data-type="VWAP" />
                          <span>VWAP</span>
                        </label>
                      </div>
                    </div>

                    <div class="ma-type-section" style="margin-top: 20px;">
                      <h4 style="color: #4a90e2; font-size: 14px; margin-bottom: 10px;">Trail Short MA Types</h4>
                      <div class="checkbox-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 8px;">
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="ALL" />
                          <span>All</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="SMA" />
                          <span>SMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="EMA" />
                          <span>EMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="HMA" checked />
                          <span>HMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="ALMA" />
                          <span>ALMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="KAMA" />
                          <span>KAMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="WMA" />
                          <span>WMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="TMA" />
                          <span>TMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="T3" />
                          <span>T3</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="DEMA" />
                          <span>DEMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="VWMA" />
                          <span>VWMA</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                          <input type="checkbox" class="opt-ma-type" data-group="trailShort" data-type="VWAP" />
                          <span>VWAP</span>
                        </label>
                      </div>
                    </div>

                    <div style="margin-top: 20px; padding: 15px; background-color: white; border-radius: 5px;">
                      <label style="display: flex; align-items: center; font-size: 14px; gap: 8px;">
                        <input type="checkbox" id="opt-lockTrailTypes" />
                        <span>Lock Trail MA Types (use same types for Long and Short)</span>
                      </label>
                      <p style="font-size: 12px; color: #666; margin: 5px 0 0 25px;">
                        When enabled, Trail Short types will match Trail Long types during optimization.
                      </p>
                    </div>
                  </div>
                </div>
              </form>
            </div>
          </div>
        </div>
      </div>

      <!-- Third column: Optimizer Run -->
      <div class="frame">
        <div class="window optimizer-run-window">
          <div class="title-bar">
            <h2>Optimizer Run</h2>
          </div>
          <div class="content">
            <!-- Walk-Forward Analysis Section -->
            <div class="wf-section" style="margin-top: 0; padding: 20px; border: 2px solid #3498db; border-radius: 8px; background-color: #f8f9fa;">
              <h3 style="color: #3498db; margin-bottom: 12px;">‚ö° Walk-Forward Analysis</h3>

              <div class="form-group vertical" style="align-items: flex-start;">
                <label style="margin-bottom: 8px;">
                  <input type="checkbox" id="enableWF" onchange="toggleWFSettings()" />
                  <strong>Enable Walk-Forward Optimization</strong>
                </label>
                <p style="font-size: 12px; color: #666; margin: 0;">
                  Splits data into multiple training/testing windows to find robust parameters.
                </p>
              </div>

              <div id="wfSettings" style="display: none; margin-top: 20px;">
                <div class="form-group" style="margin-bottom: 12px;">
                  <label style="min-width: 150px;">Number of Windows:</label>
                  <input type="number" id="wfNumWindows" value="5" min="3" max="10" style="width: 100px;" />
                  <span style="font-size: 12px; color: #666; margin-left: 10px;">(Recommended: 5-6 for 1-2 years of data)</span>
                </div>

                <div class="form-group" style="margin-bottom: 12px;">
                  <label style="min-width: 150px;">Gap (bars):</label>
                  <input type="number" id="wfGapBars" value="100" min="0" max="500" style="width: 100px;" />
                  <span style="font-size: 12px; color: #666; margin-left: 10px;">(Bars between training and testing to prevent look-ahead bias)</span>
                </div>

                <div class="form-group" style="margin-bottom: 12px;">
                  <label style="min-width: 150px;">Top-K per Window:</label>
                  <input type="number" id="wfTopK" value="20" min="5" max="50" style="width: 100px;" />
                  <span style="font-size: 12px; color: #666; margin-left: 10px;">(Best parameter sets to test on each window)</span>
                </div>

                <div style="background-color: #e8f4f8; padding: 15px; border-radius: 5px;">
                  <strong>Fixed Settings (Stage 1):</strong>
                  <ul style="margin-top: 10px; font-size: 13px; color: #555; padding-left: 18px;">
                    <li>WF Zone: 80% of data</li>
                    <li>Forward Reserve: 20% of data</li>
                    <li>Each window: 70% training (IS), 30% testing (OOS)</li>
                    <li>Rolling window mode</li>
                  </ul>
                </div>
              </div>
            </div>

            <div class="opt-actions" style="margin-top: 20px;">
              <button type="button" id="runOptimizationBtn" onclick="document.getElementById('optimizerForm').requestSubmit()">Run Optimization</button>
            </div>

            <div id="optimizerProgress" style="display: none;">
              <div id="optunaProgress" style="display: none;">
                <div class="progress-bar">
                  <div id="optunaProgressFill" class="progress-fill"></div>
                </div>
                <div id="optunaProgressText">Trial: 0 / 500 (0%)</div>

                <div
                  style="margin-top: 15px; padding: 12px; background: #ffffff; border: 1px solid #cccccc; border-radius: 4px;"
                >
                  <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #2a2a2a;">Best trial so far:</div>
                  <div id="optunaBestTrial" style="font-size: 12px; color: #2a2a2a; line-height: 1.6;">
                    Waiting for first trial...
                  </div>
                </div>

                <div style="margin-top: 10px; font-size: 12px; color: #5a5a5a;">
                  <span id="optunaCurrentTrial">Current trial: -</span><br />
                  <span id="optunaEta">Est. time remaining: -</span>
                </div>
              </div>
            </div>

            <div id="wfResults" style="display: none; margin-top: 30px;">
              <h3 style="margin-bottom: 15px;">Walk-Forward Results</h3>

              <div id="wfStatus" style="margin-bottom: 15px; font-size: 14px; color: #555;"></div>

              <div id="wfSummary" style="background-color: #d4edda; padding: 15px; border-radius: 5px; margin-bottom: 20px;"></div>

              <h4 style="margin-bottom: 10px;">Top 10 Parameter Sets</h4>
              <table id="wfTable" style="width: 100%; border-collapse: collapse;">
                <thead>
                  <tr style="background-color: #3498db; color: white;">
                    <th style="padding: 10px; border: 1px solid #ddd;">Rank</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">Param ID</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">Appearance</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">Avg OOS Profit %</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">OOS Win Rate</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">Forward Profit %</th>
                  </tr>
                </thead>
                <tbody id="wfTableBody"></tbody>
              </table>

              <div style="margin-top: 20px; font-size: 14px; color: #666;">
                Full detailed results will be automatically downloaded as CSV.
              </div>
            </div>

            <div id="optimizerResults" class="results-area" style="display: none;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // STRATEGY MANAGEMENT
    // ============================================

    let currentStrategyId = null;
    let currentStrategyConfig = null;

    /**
     * Load list of available strategies on page load
     */
    async function loadStrategiesList() {
      try {
        const response = await fetch('/api/strategies');
        const data = await response.json();

        const select = document.getElementById('strategySelect');
        if (!select) {
          return;
        }

        select.innerHTML = '';

        if (!data.strategies || data.strategies.length === 0) {
          select.innerHTML = '<option value="">No strategies found</option>';
          console.error('No strategies discovered');
          return;
        }

        data.strategies.forEach((strategy) => {
          const option = document.createElement('option');
          option.value = strategy.id;
          option.textContent = `${strategy.name} ${strategy.version}`;
          select.appendChild(option);
        });

        if (data.strategies.length > 0) {
          currentStrategyId = data.strategies[0].id;
          select.value = currentStrategyId;
          await loadStrategyConfig(currentStrategyId);
        }
      } catch (error) {
        console.error('Failed to load strategies:', error);
        alert('Error loading strategies. Check console for details.');
      }
    }

    /**
     * Handle strategy selection change
     */
    async function handleStrategyChange() {
      const select = document.getElementById('strategySelect');
      currentStrategyId = select?.value || null;

      if (!currentStrategyId) {
        return;
      }

      await loadStrategyConfig(currentStrategyId);
    }

    /**
     * Load strategy configuration and generate forms
     */
    async function loadStrategyConfig(strategyId) {
      try {
        const response = await fetch(`/api/strategies/${strategyId}/config`);

        if (!response.ok) {
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }

        const config = await response.json();

        if (!config || typeof config !== 'object') {
          throw new Error('Invalid config format');
        }

        if (!config.parameters || typeof config.parameters !== 'object') {
          throw new Error('Missing parameters in config');
        }

        currentStrategyConfig = config;

        try {
          updateStrategyInfo(config);
        } catch (err) {
          console.warn('Failed to update strategy info:', err);
        }

        try {
          generateBacktestForm(config);
        } catch (err) {
          console.error('Failed to generate backtest form:', err);
          alert('Error generating backtest form. Please refresh the page.');
          return;
        }

        try {
          generateOptimizerForm(config);
        } catch (err) {
          console.error('Failed to generate optimizer form:', err);
          alert('Error generating optimizer form. Please refresh the page.');
          return;
        }

        console.log(`‚úì Loaded strategy: ${config.name}`);
      } catch (error) {
        console.error('Failed to load strategy config:', error);
        if (!currentStrategyConfig || !currentStrategyConfig.parameters) {
          alert(`Error loading strategy configuration: ${error.message}\n\nPlease check browser console for details.`);
        } else {
          console.warn('Non-critical error during strategy load, but forms populated successfully');
        }
      }
    }

    /**
     * Update strategy info panel
     */
    function updateStrategyInfo(config) {
      const info = document.getElementById('strategyInfo');
      if (!info) {
        return;
      }

      document.getElementById('strategyName').textContent = config.name || '';
      document.getElementById('strategyVersion').textContent = config.version || '';
      document.getElementById('strategyDescription').textContent = config.description || 'N/A';
      document.getElementById('strategyParamCount').textContent = Object.keys(config.parameters || {}).length;
      info.style.display = 'block';
    }

    /**
     * Generate backtest parameters form from config
     */
    function generateBacktestForm(config) {
      const container = document.getElementById('backtestParamsContent');
      if (!container) {
        return;
      }

      container.innerHTML = '';

      const params = config.parameters || {};
      const groups = {};

      for (const [paramName, paramDef] of Object.entries(params)) {
        const group = paramDef.group || 'Other';
        if (!groups[group]) {
          groups[group] = [];
        }
        groups[group].push({ name: paramName, def: paramDef });
      }

      for (const [groupName, groupParams] of Object.entries(groups)) {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'param-group';
        groupDiv.style.marginBottom = '25px';
        groupDiv.style.flexDirection = 'column';
        groupDiv.style.alignItems = 'flex-start';

        const groupTitle = document.createElement('h4');
        groupTitle.textContent = groupName;
        groupTitle.style.color = '#4a90e2';
        groupTitle.style.marginBottom = '15px';
        groupDiv.appendChild(groupTitle);

        groupParams.forEach(({ name, def }) => {
          const formGroup = createFormField(name, def, 'backtest');
          groupDiv.appendChild(formGroup);
        });

        container.appendChild(groupDiv);
      }
    }

    /**
     * Generate optimizer parameters form from strategy config.
     * Only shows parameters where optimize.enabled === true.
     */
    function generateOptimizerForm(config) {
      const container = document.getElementById('optimizerParamsContainer');
      if (!container) {
        console.error('Optimizer container not found (#optimizerParamsContainer)');
        return;
      }

      container.innerHTML = '';

      const params = config.parameters || {};
      const groups = {};

      for (const [paramName, paramDef] of Object.entries(params)) {
        if (paramDef.optimize && paramDef.optimize.enabled) {
          const group = paramDef.group || 'Other';
          if (!groups[group]) {
            groups[group] = [];
          }
          groups[group].push({ name: paramName, def: paramDef });
        }
      }

      const totalParams = Object.values(groups).reduce((sum, g) => sum + g.length, 0);
      if (totalParams === 0) {
        container.innerHTML = '<p class="warning">No optimizable parameters defined for this strategy.</p>';
        const maTypeContainer = getMaTypeContainer();
        if (maTypeContainer) {
          maTypeContainer.style.display = 'none';
        }
        bindOptimizerInputs();
        return;
      }

      for (const [groupName, groupParams] of Object.entries(groups)) {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'opt-section';

        const groupTitle = document.createElement('div');
        groupTitle.className = 'opt-section-title';
        groupTitle.textContent = groupName;
        groupDiv.appendChild(groupTitle);

        groupParams.forEach(({ name, def }) => {
          const row = createOptimizerRow(name, def);
          groupDiv.appendChild(row);
        });

        container.appendChild(groupDiv);
      }

      bindOptimizerInputs();
      calculateTotalCombinations();

      console.log(`Generated optimizer form with ${totalParams} parameters`);
    }

    /**
     * Create a single optimizer parameter row.
     */
    function createOptimizerRow(paramName, paramDef) {
      const row = document.createElement('div');
      row.className = 'opt-row';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `opt-${paramName}`;
      checkbox.checked = Boolean(paramDef.optimize && paramDef.optimize.enabled);
      checkbox.dataset.paramName = paramName;

      const label = document.createElement('label');
      label.className = 'opt-label';
      label.htmlFor = `opt-${paramName}`;
      label.textContent = paramDef.label || paramName;

      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'opt-controls';

      const isInt = paramDef.type === 'int' || paramDef.type === 'integer';
      const defaultStep = isInt ? 1 : 0.1;
      const minStep = isInt ? 1 : 0.01;

      const fromLabel = document.createElement('label');
      fromLabel.textContent = 'From:';
      const fromInput = document.createElement('input');
      fromInput.className = 'tiny-input';
      fromInput.id = `opt-${paramName}-from`;
      fromInput.type = 'number';
      fromInput.value = paramDef.optimize?.min ?? paramDef.min ?? 0;
      fromInput.step = paramDef.optimize?.step || paramDef.step || defaultStep;
      fromInput.dataset.paramName = paramName;

      const toLabel = document.createElement('label');
      toLabel.textContent = 'To:';
      const toInput = document.createElement('input');
      toInput.className = 'tiny-input';
      toInput.id = `opt-${paramName}-to`;
      toInput.type = 'number';
      toInput.value = paramDef.optimize?.max ?? paramDef.max ?? 100;
      toInput.step = paramDef.optimize?.step || paramDef.step || defaultStep;
      toInput.dataset.paramName = paramName;

      const stepLabel = document.createElement('label');
      stepLabel.textContent = 'Step:';
      const stepInput = document.createElement('input');
      stepInput.className = 'tiny-input';
      stepInput.id = `opt-${paramName}-step`;
      stepInput.type = 'number';
      stepInput.value = paramDef.optimize?.step || paramDef.step || defaultStep;
      stepInput.step = minStep;
      stepInput.min = minStep;
      stepInput.dataset.paramName = paramName;

      controlsDiv.appendChild(fromLabel);
      controlsDiv.appendChild(fromInput);
      controlsDiv.appendChild(toLabel);
      controlsDiv.appendChild(toInput);
      controlsDiv.appendChild(stepLabel);
      controlsDiv.appendChild(stepInput);

      row.appendChild(checkbox);
      row.appendChild(label);
      row.appendChild(controlsDiv);

      return row;
    }

    function getOptimizerParamElements() {
      const params = currentStrategyConfig?.parameters || {};
      const checkboxes = document.querySelectorAll(
        '[id^="opt-"]:not([id$="-from"]):not([id$="-to"]):not([id$="-step"])'
      );

      return Array.from(checkboxes).map((checkbox) => {
        const paramName = checkbox.dataset.paramName || checkbox.id.replace(/^opt-/, '');
        return {
          name: paramName,
          checkbox,
          fromInput: document.getElementById(`opt-${paramName}-from`),
          toInput: document.getElementById(`opt-${paramName}-to`),
          stepInput: document.getElementById(`opt-${paramName}-step`),
          def: params[paramName] || {}
        };
      });
    }

    /**
     * Create a form field based on parameter definition
     */
    function createFormField(paramName, paramDef, prefix) {
      const formGroup = document.createElement('div');
      formGroup.className = 'form-group';
      formGroup.style.marginBottom = '15px';

      const label = document.createElement('label');
      label.textContent = paramDef.label || paramName;
      label.style.display = 'inline-block';
      label.style.width = '200px';
      formGroup.appendChild(label);

      let input;

      if (paramDef.type === 'select') {
        input = document.createElement('select');
        input.id = `${prefix}_${paramName}`;
        input.name = paramName;
        input.style.padding = '5px';
        input.style.minWidth = '150px';

        (paramDef.options || []).forEach((option) => {
          const opt = document.createElement('option');
          opt.value = option;
          opt.textContent = option;
          if (option === paramDef.default) {
            opt.selected = true;
          }
          input.appendChild(opt);
        });
      } else if (paramDef.type === 'int' || paramDef.type === 'float') {
        input = document.createElement('input');
        input.type = 'number';
        input.id = `${prefix}_${paramName}`;
        input.name = paramName;
        input.value = paramDef.default ?? 0;
        input.min = paramDef.min !== undefined ? paramDef.min : '';
        input.max = paramDef.max !== undefined ? paramDef.max : '';
        input.step = paramDef.step || (paramDef.type === 'int' ? 1 : 0.1);
        input.style.padding = '5px';
        input.style.width = '120px';
      } else if (paramDef.type === 'bool') {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.id = `${prefix}_${paramName}`;
        input.name = paramName;
        input.checked = paramDef.default || false;
      }

      if (input) {
        formGroup.appendChild(input);
      }

      return formGroup;
    }

    document.addEventListener('DOMContentLoaded', () => {

      loadStrategiesList();

      const collapsibles = document.querySelectorAll('.collapsible');
      collapsibles.forEach((collapsible) => {
        const header = collapsible.querySelector('.collapsible-header');
        header.addEventListener('click', () => {
          collapsible.classList.toggle('open');
        });
      });

      // Reference configuration used to calibrate the historical ETA formula:
      // 2025-04-01 ‚Üí 2025-09-01 on a 15 minute timeframe results in 14 689 bars.
      const REFERENCE_BAR_COUNT = 14689;

      const SCORE_METRICS = ['romad', 'sharpe', 'pf', 'ulcer', 'recovery', 'consistency'];
      const SCORE_DEFAULT_THRESHOLD = 60;
      const SCORE_DEFAULT_WEIGHTS = {
        romad: 0.25,
        sharpe: 0.20,
        pf: 0.20,
        ulcer: 0.15,
        recovery: 0.10,
        consistency: 0.10
      };
      const SCORE_DEFAULT_ENABLED = {
        romad: true,
        sharpe: true,
        pf: true,
        ulcer: true,
        recovery: true,
        consistency: true
      };
      const SCORE_DEFAULT_INVERT = {
        ulcer: true
      };

      let defaults = {
        dateFilter: true,
        backtester: true,
        startDate: '2025-04-01',
        startTime: '00:00',
        endDate: '2025-09-01',
        endTime: '00:00',
        csvPath: '',
        trendMATypes: [...MA_TYPES],
        maLength: 45,
        closeCountLong: 7,
        closeCountShort: 5,
        stopLongX: 2,
        stopLongRR: 3,
        stopLongLP: 2,
        stopShortX: 2,
        stopShortRR: 3,
        stopShortLP: 2,
        stopLongMaxPct: 3.0,
        stopShortMaxPct: 3.0,
        stopLongMaxDays: 2,
        stopShortMaxDays: 4,
        trailRRLong: 1,
        trailRRShort: 1,
        trailLongTypes: ['SMA'],
        trailLongLength: 160,
        trailLongOffset: -1,
        trailShortTypes: ['SMA'],
        trailLock: false,
        trailShortLength: 160,
        trailShortOffset: 1,
        riskPerTrade: 2,
        contractSize: 0.01,
        workerProcesses: 6,
        minProfitFilter: false,
        minProfitThreshold: 0,
        scoreFilterEnabled: false,
        scoreThreshold: SCORE_DEFAULT_THRESHOLD,
        scoreWeights: { ...SCORE_DEFAULT_WEIGHTS },
        scoreEnabledMetrics: { ...SCORE_DEFAULT_ENABLED },
        scoreInvertMetrics: { ...SCORE_DEFAULT_INVERT }
      };

      const DEFAULT_PRESET_KEY = 'defaults';
      const PRESET_NAME_PATTERN = /^[A-Za-z0-9 _-]{1,64}$/;
      const PRESET_LABELS = {
        dateFilter: 'Date Filter',
        backtester: 'Backtester',
        startDate: 'Start Date',
        startTime: 'Start Time',
        endDate: 'End Date',
        endTime: 'End Time',
        csvPath: 'CSV Path',
        trendMATypes: 'Trend MA Types',
        maLength: 'MA Length',
        closeCountLong: 'Close Count Long',
        closeCountShort: 'Close Count Short',
        stopLongX: 'Stop Long X',
        stopLongRR: 'Stop Long RR',
        stopLongLP: 'Stop Long LP',
        stopShortX: 'Stop Short X',
        stopShortRR: 'Stop Short RR',
        stopShortLP: 'Stop Short LP',
        stopLongMaxPct: 'Stop Long Max %',
        stopShortMaxPct: 'Stop Short Max %',
        stopLongMaxDays: 'Stop Long Max Days',
        stopShortMaxDays: 'Stop Short Max Days',
        trailRRLong: 'Trail RR Long',
        trailRRShort: 'Trail RR Short',
        trailLongTypes: 'Trail MA Long Type',
        trailLongLength: 'Trail MA Long Length',
        trailLongOffset: 'Trail MA Long Offset',
        trailLock: 'Trail MA Lock',
        trailShortTypes: 'Trail MA Short Type',
        trailShortLength: 'Trail MA Short Length',
        trailShortOffset: 'Trail MA Short Offset',
        riskPerTrade: 'Risk Per Trade',
        contractSize: 'Contract Size',
        workerProcesses: 'Worker Processes',
        minProfitFilter: 'Net Profit Filter',
        minProfitThreshold: 'Net Profit Min %',
        scoreFilterEnabled: 'Score Filter',
        scoreThreshold: 'Score Min Score',
        scoreWeights: 'Score Weights',
        scoreEnabledMetrics: 'Score Enabled Metrics',
        scoreInvertMetrics: 'Score Invert Metrics'
      };

      let knownPresets = [];

      window.toggleWFSettings = function toggleWFSettings() {
        const wfToggle = document.getElementById('enableWF');
        const wfSettings = document.getElementById('wfSettings');
        if (!wfToggle || !wfSettings) {
          return;
        }
        wfSettings.style.display = wfToggle.checked ? 'block' : 'none';
      };

      const optimizerForm = document.getElementById('optimizerForm');
      const optimizerResultsEl = document.getElementById('optimizerResults');
      const progressContainer = document.getElementById('optimizerProgress');
      const optunaProgress = document.getElementById('optunaProgress');
      const optunaProgressFill = document.getElementById('optunaProgressFill');
      const optunaProgressText = document.getElementById('optunaProgressText');
      const optunaBestTrial = document.getElementById('optunaBestTrial');
      const optunaCurrentTrial = document.getElementById('optunaCurrentTrial');
      const optunaEta = document.getElementById('optunaEta');
      const totalCombinationsEl = document.getElementById('totalCombinations');
      const estimatedTimeEl = document.getElementById('estimatedTime');
      const csvFileInputEl = document.getElementById('csvFile');
      const selectedFilesWrapper = document.getElementById('selectedFilesWrapper');
      const selectedFilesList = document.getElementById('selectedFilesList');
      const optunaSettings = document.getElementById('optunaSettings');
      const optunaTarget = document.getElementById('optunaTarget');
      const budgetModeRadios = document.querySelectorAll('input[name="budgetMode"]');
      const optunaTrials = document.getElementById('optunaTrials');
      const optunaTimeLimit = document.getElementById('optunaTimeLimit');
      const optunaConvergence = document.getElementById('optunaConvergence');
      const optunaPruning = document.getElementById('optunaPruning');
      const optunaSampler = document.getElementById('optunaSampler');
      const optunaPruner = document.getElementById('optunaPruner');
      const optunaWarmupTrials = document.getElementById('optunaWarmupTrials');
      const optunaSaveStudy = document.getElementById('optunaSaveStudy');
      const wfResultsContainer = document.getElementById('wfResults');
      const wfSummaryEl = document.getElementById('wfSummary');
      const wfTableBody = document.getElementById('wfTableBody');
      const wfStatusEl = document.getElementById('wfStatus');
      const linkToScoreConfig = document.getElementById('linkToScoreConfig');
      const presetDropdownEl = document.getElementById('presetDropdown');
      const presetToggleEl = document.getElementById('presetToggle');
      const presetMenuEl = document.getElementById('presetMenu');
      const presetListEl = document.getElementById('presetList');
      const presetEmptyEl = document.getElementById('presetEmpty');
      const presetImportInput = document.getElementById('presetImportInput');
      let selectedCsvPath = '';

      function renderSelectedFiles(files) {
        if (!selectedFilesWrapper || !selectedFilesList) {
          return;
        }

        const entries = [];
        if (files && files.length) {
          files.forEach((file) => {
            entries.push(file.name);
          });
        } else if (selectedCsvPath) {
          entries.push(selectedCsvPath);
        }

        selectedFilesList.innerHTML = '';
        if (!entries.length) {
          selectedFilesWrapper.style.display = 'none';
          return;
        }

        const fragment = document.createDocumentFragment();
        entries.forEach((label) => {
          const item = document.createElement('li');
          item.textContent = label;
          fragment.appendChild(item);
        });

        selectedFilesList.appendChild(fragment);
        selectedFilesWrapper.style.display = 'block';
      }

      function syncBudgetInputs() {
        if (!budgetModeRadios || !budgetModeRadios.length) {
          return;
        }

        const selected = Array.from(budgetModeRadios).find((radio) => radio.checked)?.value || 'trials';

        if (optunaTrials) {
          optunaTrials.disabled = selected !== 'trials';
        }
        if (optunaTimeLimit) {
          optunaTimeLimit.disabled = selected !== 'time';
        }
        if (optunaConvergence) {
          optunaConvergence.disabled = selected !== 'convergence';
        }
      }

      budgetModeRadios.forEach((radio) => {
        radio.addEventListener('change', syncBudgetInputs);
      });

      if (linkToScoreConfig) {
        linkToScoreConfig.addEventListener('click', (event) => {
          event.preventDefault();
          const scoreConfigBtn = document.getElementById('scoreConfigBtn');
          const scoreConfigCollapsible = document.getElementById('scoreConfigCollapsible');
          if (scoreConfigBtn && scoreConfigCollapsible) {
            if (!scoreConfigCollapsible.classList.contains('open')) {
              scoreConfigCollapsible.classList.add('open');
            }
            scoreConfigBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
            scoreConfigCollapsible.style.outline = '3px solid #90caf9';
            window.setTimeout(() => {
              scoreConfigCollapsible.style.outline = '';
            }, 2000);
          }
        });
      }

      syncBudgetInputs();
      toggleWFSettings();

      function clonePreset(data) {
        try {
          return JSON.parse(JSON.stringify(data || {}));
        } catch (error) {
          return {};
        }
      }

      function formatPresetLabel(key) {
        return PRESET_LABELS[key] || key;
      }

      function showErrorMessage(message) {
        const errorEl = document.getElementById('error');
        if (!errorEl) {
          return;
        }
        errorEl.textContent = message;
        errorEl.style.display = message ? 'block' : 'none';
      }

      function clearErrorMessage() {
        showErrorMessage('');
      }

      function showResultsMessage(message) {
        const resultsEl = document.getElementById('results');
        if (!resultsEl) {
          return;
        }
        resultsEl.textContent = message;
        resultsEl.classList.remove('loading');
        if (message) {
          resultsEl.classList.add('ready');
        } else {
          resultsEl.classList.remove('ready');
        }
      }

      function setCheckboxValue(id, checked) {
        const element = document.getElementById(id);
        if (!element) {
          return;
        }
        element.checked = Boolean(checked);
      }

      function setInputValue(id, value) {
        const element = document.getElementById(id);
        if (!element) {
          return;
        }
        if (value === undefined || value === null) {
          element.value = '';
        } else {
          element.value = value;
        }
      }

      function parseNumber(value, fallback = 0) {
        const parsed = Number(value);
        return Number.isFinite(parsed) ? parsed : fallback;
      }

      function getMinProfitElements() {
        return {
          checkbox: document.getElementById('minProfitFilter'),
          input: document.getElementById('minProfitThreshold'),
          group: document.getElementById('minProfitFilterGroup'),
        };
      }

      function getScoreElements() {
        return {
          checkbox: document.getElementById('scoreFilter'),
          input: document.getElementById('scoreThreshold'),
          group: document.getElementById('scoreFilterGroup'),
        };
      }

      function syncMinProfitFilterUI() {
        const { checkbox, input, group } = getMinProfitElements();
        if (!checkbox || !input) {
          return;
        }

        const isChecked = Boolean(checkbox.checked);
        input.disabled = !isChecked;
        if (group) {
          group.classList.toggle('active', isChecked);
        }
      }

      function syncScoreFilterUI() {
        const { checkbox, input, group } = getScoreElements();
        if (!checkbox || !input) {
          return;
        }

        const isChecked = Boolean(checkbox.checked);
        input.disabled = !isChecked;
        if (group) {
          group.classList.toggle('active', isChecked);
        }
      }

      function readScoreUIState() {
        const { checkbox, input } = getScoreElements();
        const weights = {};
        const enabled = {};
        SCORE_METRICS.forEach((metric) => {
          const metricCheckbox = document.getElementById(`metric-${metric}`);
          const weightInput = document.getElementById(`weight-${metric}`);
          enabled[metric] = Boolean(metricCheckbox && metricCheckbox.checked);
          const rawWeight = weightInput ? Number(weightInput.value) : NaN;
          const fallback = SCORE_DEFAULT_WEIGHTS[metric] ?? 0;
          const parsedWeight = Number.isFinite(rawWeight) ? rawWeight : fallback;
          weights[metric] = Math.min(1, Math.max(0, parsedWeight));
        });

        const invertCheckbox = document.getElementById('invert-ulcer');
        const invert = {
          ulcer: Boolean(invertCheckbox && invertCheckbox.checked),
        };

        const thresholdRaw = input ? Number(input.value) : NaN;
        const threshold = Number.isFinite(thresholdRaw)
          ? Math.min(100, Math.max(0, thresholdRaw))
          : SCORE_DEFAULT_THRESHOLD;

        return {
          scoreFilterEnabled: Boolean(checkbox && checkbox.checked),
          scoreThreshold: threshold,
          scoreWeights: weights,
          scoreEnabledMetrics: enabled,
          scoreInvertMetrics: invert,
        };
      }

      function applyScoreSettings(settings = {}) {
        const filterCheckbox = document.getElementById('scoreFilter');
        const thresholdInput = document.getElementById('scoreThreshold');
        const formulaPreview = document.getElementById('formulaPreview');

        const effectiveWeights = { ...SCORE_DEFAULT_WEIGHTS, ...(settings.scoreWeights || {}) };
        const effectiveEnabled = { ...SCORE_DEFAULT_ENABLED, ...(settings.scoreEnabledMetrics || {}) };
        const effectiveInvert = { ...SCORE_DEFAULT_INVERT, ...(settings.scoreInvertMetrics || {}) };

        const filterEnabled = Object.prototype.hasOwnProperty.call(settings, 'scoreFilterEnabled')
          ? Boolean(settings.scoreFilterEnabled)
          : Boolean(defaults.scoreFilterEnabled);
        const thresholdValue = Object.prototype.hasOwnProperty.call(settings, 'scoreThreshold')
          ? Number(settings.scoreThreshold)
          : Number(defaults.scoreThreshold);

        if (filterCheckbox) {
          filterCheckbox.checked = filterEnabled;
        }
        if (thresholdInput) {
          const safeValue = Number.isFinite(thresholdValue)
            ? Math.min(100, Math.max(0, thresholdValue))
            : SCORE_DEFAULT_THRESHOLD;
          thresholdInput.value = safeValue;
        }

        SCORE_METRICS.forEach((metric) => {
          const metricCheckbox = document.getElementById(`metric-${metric}`);
          const weightInput = document.getElementById(`weight-${metric}`);
          if (metricCheckbox) {
            metricCheckbox.checked = Boolean(effectiveEnabled[metric]);
          }
          if (weightInput) {
            const weightValue = Number.isFinite(Number(effectiveWeights[metric]))
              ? Math.min(1, Math.max(0, Number(effectiveWeights[metric])))
              : SCORE_DEFAULT_WEIGHTS[metric];
            weightInput.value = weightValue;
          }
        });

        const invertCheckbox = document.getElementById('invert-ulcer');
        if (invertCheckbox) {
          invertCheckbox.checked = Boolean(effectiveInvert.ulcer);
        }

        syncScoreFilterUI();
        if (formulaPreview) {
          updateScoreFormulaPreview();
        }
      }

      function updateScoreFormulaPreview() {
        const previewEl = document.getElementById('formulaPreview');
        if (!previewEl) {
          return;
        }

        const state = readScoreUIState();
        const enabledWeights = SCORE_METRICS
          .filter((metric) => state.scoreEnabledMetrics[metric] && state.scoreWeights[metric] > 0)
          .map((metric) => {
            const labelMap = {
              romad: 'RoMaD',
              sharpe: 'Sharpe Ratio',
              pf: 'Profit Factor',
              ulcer: 'Ulcer Index',
              recovery: 'Recovery Factor',
              consistency: 'Consistency Score',
            };
            const label = labelMap[metric] || metric;
            const weight = state.scoreWeights[metric];
            return `${weight.toFixed(2)}√ó${label}`;
          });

        if (!enabledWeights.length) {
          previewEl.textContent = 'Score disabled (no metrics enabled).';
          return;
        }
        previewEl.textContent = `Score = ${enabledWeights.join(' + ')}`;
      }

      function collectScoreConfig() {
        const state = readScoreUIState();
        const config = {
          filter_enabled: state.scoreFilterEnabled,
          min_score_threshold: state.scoreThreshold,
          weights: {},
          enabled_metrics: {},
          invert_metrics: {},
          normalization_method: 'percentile'
        };

        SCORE_METRICS.forEach((metric) => {
          config.enabled_metrics[metric] = Boolean(state.scoreEnabledMetrics[metric]);
          const normalizedWeight = Math.min(1, Math.max(0, state.scoreWeights[metric]));
          config.weights[metric] = config.enabled_metrics[metric] ? normalizedWeight : 0;
        });

        if (state.scoreInvertMetrics.ulcer) {
          config.invert_metrics.ulcer = true;
        }

        return config;
      }

      if (csvFileInputEl) {
        csvFileInputEl.addEventListener('change', () => {
          const files = Array.from(csvFileInputEl.files || []);
          if (files.length) {
            const firstFile = files[0];
            const derivedPath =
              (firstFile && (firstFile.path || firstFile.webkitRelativePath)) || '';
            const fallbackName = firstFile && firstFile.name ? firstFile.name : '';
            selectedCsvPath = (derivedPath || fallbackName || '').trim();
          } else {
            selectedCsvPath = '';
          }
          renderSelectedFiles(files);
          calculateTotalCombinations();
        });
      }

      function setCheckboxGroup(group, selectedTypes) {
        const { allCheckbox, checkboxes } = getMaTypeCheckboxes(group);
        if (!allCheckbox || !checkboxes.length) {
          return;
        }
        const normalized = new Set(selectedTypes);
        const shouldSelectAll = MA_TYPES.every((type) => normalized.has(type));
        allCheckbox.checked = shouldSelectAll;
        checkboxes.forEach((checkbox) => {
          checkbox.checked = shouldSelectAll || normalized.has(checkbox.dataset.type);
        });
      }

      function collectSelectedTypes(group) {
        return [];
      }

      function syncAllToggle(group) {
        const { allCheckbox, checkboxes } = getMaTypeCheckboxes(group);
        if (!allCheckbox || !checkboxes.length) {
          return;
        }
        const allChecked = checkboxes.every((checkbox) => checkbox.checked);
        allCheckbox.checked = allChecked;
      }

      function bindMASelectors() {
        ['trend', 'trailLong', 'trailShort'].forEach((group) => {
          const { allCheckbox, checkboxes } = getMaTypeCheckboxes(group);

          if (!allCheckbox || !checkboxes.length) {
            return;
          }

          allCheckbox.addEventListener('change', () => {
            checkboxes.forEach((checkbox) => {
              checkbox.checked = allCheckbox.checked;
            });
            calculateTotalCombinations();
          });

          checkboxes.forEach((checkbox) => {
            checkbox.addEventListener('change', () => {
              syncAllToggle(group);
              calculateTotalCombinations();
            });
          });

          // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ ALL –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
          syncAllToggle(group);
        });
      }

      function applyPresetValues(values, { clearResults = false } = {}) {
        if (!values || typeof values !== 'object') {
          return;
        }

        if (Object.prototype.hasOwnProperty.call(values, 'csvPath')) {
          const csvPathValue = typeof values.csvPath === 'string' ? values.csvPath.trim() : '';
          selectedCsvPath = csvPathValue;
        } else {
          selectedCsvPath = '';
        }

        if (Object.prototype.hasOwnProperty.call(values, 'dateFilter')) {
          setCheckboxValue('dateFilter', values.dateFilter);
        }
        if (Object.prototype.hasOwnProperty.call(values, 'backtester')) {
          setCheckboxValue('backtester', values.backtester);
        }
        if (Object.prototype.hasOwnProperty.call(values, 'trailLock')) {
          setCheckboxValue('trailLock', values.trailLock);
          setCheckboxValue('opt-lockTrailTypes', values.trailLock);
        }

        if (Object.prototype.hasOwnProperty.call(values, 'startDate')) {
          setInputValue('startDate', values.startDate);
        }
        if (Object.prototype.hasOwnProperty.call(values, 'startTime')) {
          setInputValue('startTime', values.startTime);
        }
        if (Object.prototype.hasOwnProperty.call(values, 'endDate')) {
          setInputValue('endDate', values.endDate);
        }
        if (Object.prototype.hasOwnProperty.call(values, 'endTime')) {
          setInputValue('endTime', values.endTime);
        }

        const numericFields = [
          'maLength',
          'closeCountLong',
          'closeCountShort',
          'stopLongX',
          'stopLongRR',
          'stopLongLP',
          'stopShortX',
          'stopShortRR',
          'stopShortLP',
          'stopLongMaxPct',
          'stopShortMaxPct',
          'stopLongMaxDays',
          'stopShortMaxDays',
          'trailRRLong',
          'trailRRShort',
          'trailLongLength',
          'trailLongOffset',
          'trailShortLength',
          'trailShortOffset',
          'riskPerTrade',
          'contractSize'
        ];
        numericFields.forEach((field) => {
          if (Object.prototype.hasOwnProperty.call(values, field)) {
            setInputValue(field, values[field]);
          }
        });

        if (Object.prototype.hasOwnProperty.call(values, 'workerProcesses')) {
          const workerInput = document.getElementById('workerProcesses');
          if (workerInput) {
            workerInput.value = values.workerProcesses;
          }
        }

        const { checkbox: minProfitCheckbox, input: minProfitInput } = getMinProfitElements();
        if (minProfitCheckbox && Object.prototype.hasOwnProperty.call(values, 'minProfitFilter')) {
          minProfitCheckbox.checked = Boolean(values.minProfitFilter);
        }
        if (minProfitInput && Object.prototype.hasOwnProperty.call(values, 'minProfitThreshold')) {
          setInputValue('minProfitThreshold', values.minProfitThreshold);
        }

        const scoreSettings = {
          scoreFilterEnabled: Object.prototype.hasOwnProperty.call(values, 'scoreFilterEnabled')
            ? values.scoreFilterEnabled
            : defaults.scoreFilterEnabled,
          scoreThreshold: Object.prototype.hasOwnProperty.call(values, 'scoreThreshold')
            ? values.scoreThreshold
            : defaults.scoreThreshold,
          scoreWeights: clonePreset(
            Object.prototype.hasOwnProperty.call(values, 'scoreWeights')
              ? values.scoreWeights
              : defaults.scoreWeights
          ),
          scoreEnabledMetrics: clonePreset(
            Object.prototype.hasOwnProperty.call(values, 'scoreEnabledMetrics')
              ? values.scoreEnabledMetrics
              : defaults.scoreEnabledMetrics
          ),
          scoreInvertMetrics: clonePreset(
            Object.prototype.hasOwnProperty.call(values, 'scoreInvertMetrics')
              ? values.scoreInvertMetrics
              : defaults.scoreInvertMetrics
          ),
        };
        applyScoreSettings(scoreSettings);

        // Apply dynamic strategy parameters to the generated forms
        applyDynamicBacktestParams(values);

        if (clearResults) {
          if (csvFileInputEl) {
            csvFileInputEl.value = '';
          }
          const resultsEl = document.getElementById('results');
          if (resultsEl) {
            resultsEl.textContent = '–ù–∞–∂–º–∏—Ç–µ ¬´Run¬ª –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –±—ç–∫—Ç–µ—Å—Ç–∞‚Ä¶';
            resultsEl.classList.remove('ready', 'loading');
          }
          clearErrorMessage();
          if (optimizerResultsEl) {
            optimizerResultsEl.style.display = 'none';
            optimizerResultsEl.textContent = '';
            optimizerResultsEl.classList.remove('ready', 'loading');
          }
          if (progressContainer) {
            progressContainer.style.display = 'none';
          }
        }

        const currentFiles = csvFileInputEl ? Array.from(csvFileInputEl.files || []) : [];
        renderSelectedFiles(currentFiles);
        syncMinProfitFilterUI();
        syncScoreFilterUI();
        updateScoreFormulaPreview();
        calculateTotalCombinations();
      }

      function updateDefaults(values) {
        const merged = { ...defaults, ...clonePreset(values) };
        defaults = merged;
      }

      function applyDefaults(options = {}) {
        const clearResults =
          options && Object.prototype.hasOwnProperty.call(options, 'clearResults')
            ? Boolean(options.clearResults)
            : true;
        applyPresetValues(defaults, { clearResults });
      }

      function collectPresetValues() {
        const { checkbox: minProfitCheckbox, input: minProfitInput } = getMinProfitElements();
        const workerInput = document.getElementById('workerProcesses');
        const csvPathValue = typeof selectedCsvPath === 'string' ? selectedCsvPath.trim() : '';
        const scoreState = readScoreUIState();

        // Collect dynamic strategy parameters
        const dynamicParams = collectDynamicBacktestParams();

        return {
          dateFilter: document.getElementById('dateFilter').checked,
          backtester: document.getElementById('backtester').checked,
          startDate: document.getElementById('startDate').value.trim(),
          startTime: document.getElementById('startTime').value.trim(),
          endDate: document.getElementById('endDate').value.trim(),
          endTime: document.getElementById('endTime').value.trim(),
          csvPath: csvPathValue,
          workerProcesses: workerInput
            ? parseNumber(workerInput.value, defaults.workerProcesses)
            : defaults.workerProcesses,
          minProfitFilter: Boolean(minProfitCheckbox && minProfitCheckbox.checked),
          minProfitThreshold: minProfitInput
            ? parseNumber(minProfitInput.value, defaults.minProfitThreshold)
            : defaults.minProfitThreshold,
          scoreFilterEnabled: Boolean(scoreState.scoreFilterEnabled),
          scoreThreshold: scoreState.scoreThreshold,
          scoreWeights: { ...scoreState.scoreWeights },
          scoreEnabledMetrics: { ...scoreState.scoreEnabledMetrics },
          scoreInvertMetrics: { ...scoreState.scoreInvertMetrics },
          // Include all dynamic strategy parameters
          ...dynamicParams,
        };
      }

      async function loadPreset(name, { clearResults = false } = {}) {
        let response;
        try {
          response = await fetch(`/api/presets/${encodeURIComponent(name)}`);
        } catch (error) {
          throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≤—è–∑–∞—Ç—å—Å—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–µ—Å–µ—Ç–∞.');
        }

        if (!response.ok) {
          const message = await response.text();
          throw new Error(message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–µ—Å–µ—Ç.');
        }

        const data = await response.json();
        const values = data?.values || {};
        if (name.toLowerCase() === DEFAULT_PRESET_KEY) {
          updateDefaults(values);
          applyDefaults({ clearResults });
        } else {
          applyPresetValues(values, { clearResults });
        }
        return values;
      }

      function renderPresetList() {
        if (!presetListEl || !presetEmptyEl) {
          return;
        }

        presetListEl.innerHTML = '';
        const userPresets = knownPresets.filter((item) => !item.is_default);
        if (!userPresets.length) {
          presetEmptyEl.style.display = 'block';
          return;
        }

        presetEmptyEl.style.display = 'none';
        const fragment = document.createDocumentFragment();
        userPresets.forEach((item) => {
          const row = document.createElement('div');
          row.className = 'preset-item';

          const applyButton = document.createElement('button');
          applyButton.type = 'button';
          applyButton.className = 'preset-entry';
          applyButton.textContent = item.name;
          applyButton.addEventListener('click', (event) => {
            event.stopPropagation();
            handlePresetSelection(item.name);
          });

          const actionsContainer = document.createElement('div');
          actionsContainer.className = 'preset-actions';

          const overwriteButton = document.createElement('button');
          overwriteButton.type = 'button';
          overwriteButton.className = 'preset-action-btn preset-overwrite';
          overwriteButton.setAttribute('aria-label', `–ü–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –ø—Ä–µ—Å–µ—Ç ${item.name}`);
          overwriteButton.title = '–ü–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –ø—Ä–µ—Å–µ—Ç';
          overwriteButton.textContent = '‚ü≥';
          overwriteButton.addEventListener('click', (event) => {
            event.stopPropagation();
            handlePresetOverwrite(item.name);
          });

          const deleteButton = document.createElement('button');
          deleteButton.type = 'button';
          deleteButton.className = 'preset-action-btn preset-delete';
          deleteButton.setAttribute('aria-label', `–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç ${item.name}`);
          deleteButton.title = '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç';
          deleteButton.textContent = '‚úï';
          deleteButton.addEventListener('click', (event) => {
            event.stopPropagation();
            handlePresetDelete(item.name);
          });

          actionsContainer.appendChild(overwriteButton);
          actionsContainer.appendChild(deleteButton);
          row.appendChild(applyButton);
          row.appendChild(actionsContainer);
          fragment.appendChild(row);
        });

        presetListEl.appendChild(fragment);
      }

      async function refreshPresetList(silent = false) {
        try {
          const response = await fetch('/api/presets');
          if (!response.ok) {
            const message = await response.text();
            throw new Error(message || '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–µ—Å–µ—Ç–æ–≤.');
          }
          const data = await response.json();
          knownPresets = Array.isArray(data?.presets) ? data.presets : [];
        } catch (error) {
          knownPresets = [];
          if (!silent) {
            showErrorMessage(error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–µ—Å–µ—Ç–æ–≤.');
          }
          console.error(error);
        }
        renderPresetList();
      }

      async function savePreset(name, values) {
        const response = await fetch('/api/presets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, values })
        });
        if (!response.ok) {
          const message = await response.text();
          throw new Error(message || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–µ—Å–µ—Ç.');
        }
        return response.json();
      }

      async function overwritePreset(name, values) {
        const response = await fetch(`/api/presets/${encodeURIComponent(name)}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ values })
        });
        if (!response.ok) {
          const message = await response.text();
          throw new Error(message || '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –ø—Ä–µ—Å–µ—Ç.');
        }
        return response.json();
      }

      async function saveDefaults(values) {
        const response = await fetch('/api/presets/defaults', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ values })
        });
        if (!response.ok) {
          const message = await response.text();
          throw new Error(message || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.');
        }
        return response.json();
      }

      async function deletePreset(name) {
        const response = await fetch(`/api/presets/${encodeURIComponent(name)}`, {
          method: 'DELETE'
        });
        if (!response.ok) {
          const message = await response.text();
          throw new Error(message || '–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç.');
        }
      }

      async function importPresetFromCsv(file) {
        const formData = new FormData();
        formData.append('file', file, file.name);

        const response = await fetch('/api/presets/import-csv', {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          const message = await response.text();
          throw new Error(message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ CSV.');
        }

        return response.json();
      }

      async function handleApplyDefaults() {
        closePresetMenu();
        try {
          await loadPreset(DEFAULT_PRESET_KEY, { clearResults: true });
          clearErrorMessage();
        } catch (error) {
          showErrorMessage(error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.');
        }
      }

      async function handlePresetSelection(name) {
        closePresetMenu();
        try {
          await loadPreset(name, { clearResults: false });
          clearErrorMessage();
        } catch (error) {
          showErrorMessage(error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–µ—Å–µ—Ç.');
        }
      }

      async function handleSaveAsPreset() {
        closePresetMenu();
        const values = collectPresetValues();
        let presetName = '';

        while (true) {
          const input = window.prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø—Ä–µ—Å–µ—Ç–∞:', '');
          if (input === null) {
            return;
          }
          const trimmed = input.trim();
          if (!trimmed) {
            window.alert('–ò–º—è –ø—Ä–µ—Å–µ—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.');
            continue;
          }
          if (trimmed.toLowerCase() === DEFAULT_PRESET_KEY) {
            window.alert('–ù–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–º—è "defaults".');
            continue;
          }
          if (!PRESET_NAME_PATTERN.test(trimmed)) {
            window.alert('–ò–º—è –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã, –ø—Ä–æ–±–µ–ª—ã, –¥–µ—Ñ–∏—Å—ã –∏ –Ω–∏–∂–Ω–µ–µ –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞–Ω–∏–µ.');
            continue;
          }
          if (knownPresets.some((item) => item.name.toLowerCase() === trimmed.toLowerCase())) {
            window.alert('–ü—Ä–µ—Å–µ—Ç —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.');
            continue;
          }
          presetName = trimmed;
          break;
        }

        try {
          await savePreset(presetName, values);
          await refreshPresetList(false);
          window.alert(`–ü—Ä–µ—Å–µ—Ç ¬´${presetName}¬ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω.`);
        } catch (error) {
          showErrorMessage(error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–µ—Å–µ—Ç.');
        }
      }

      async function handleSaveDefaults() {
        closePresetMenu();
        const values = collectPresetValues();
        try {
          const response = await saveDefaults(values);
          updateDefaults(response?.values || values);
          window.alert('–¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –∫–∞–∫ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ.');
        } catch (error) {
          showErrorMessage(error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.');
        }
      }

      async function handlePresetDelete(name) {
        const confirmed = window.confirm(`–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç ¬´${name}¬ª?`);
        if (!confirmed) {
          return;
        }
        closePresetMenu();
        try {
          await deletePreset(name);
          await refreshPresetList(false);
        } catch (error) {
          showErrorMessage(error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç.');
        }
      }

      async function handlePresetOverwrite(name) {
        const confirmed = window.confirm(`–ü–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –ø—Ä–µ—Å–µ—Ç ¬´${name}¬ª —Ç–µ–∫—É—â–∏–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏?`);
        if (!confirmed) {
          return;
        }
        closePresetMenu();
        const values = collectPresetValues();
        try {
          await overwritePreset(name, values);
          await refreshPresetList(false);
          window.alert(`–ü—Ä–µ—Å–µ—Ç ¬´${name}¬ª –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω.`);
        } catch (error) {
          showErrorMessage(error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –ø—Ä–µ—Å–µ—Ç.');
        }
      }

      function openPresetMenu() {
        if (!presetDropdownEl) {
          return;
        }
        presetDropdownEl.classList.add('open');
        if (presetToggleEl) {
          presetToggleEl.setAttribute('aria-expanded', 'true');
        }
        if (presetMenuEl) {
          presetMenuEl.setAttribute('aria-hidden', 'false');
        }
      }

      function closePresetMenu() {
        if (!presetDropdownEl) {
          return;
        }
        presetDropdownEl.classList.remove('open');
        if (presetToggleEl) {
          presetToggleEl.setAttribute('aria-expanded', 'false');
        }
        if (presetMenuEl) {
          presetMenuEl.setAttribute('aria-hidden', 'true');
        }
      }

      function togglePresetMenu() {
        if (!presetDropdownEl) {
          return;
        }
        if (presetDropdownEl.classList.contains('open')) {
          closePresetMenu();
        } else {
          openPresetMenu();
        }
      }

      function handleImportAction() {
        if (!presetImportInput) {
          return;
        }
        presetImportInput.value = '';
        presetImportInput.click();
      }

      async function initializePresets() {
        try {
          await loadPreset(DEFAULT_PRESET_KEY, { clearResults: true });
          clearErrorMessage();
        } catch (error) {
          console.error(error);
          applyDefaults({ clearResults: true });
        }
        await refreshPresetList(true);
      }

      function composeDateTime(datePart, timePart) {
        const date = (datePart || '').trim();
        const time = (timePart || '').trim();
        if (!date) {
          return '';
        }
        const normalizedTime = time || '00:00';
        return `${date}T${normalizedTime}`;
      }

      function collectDynamicBacktestParams() {
        const params = {};
        const container = document.getElementById('backtestParamsContent');

        if (!container || !currentStrategyConfig || !currentStrategyConfig.parameters) {
          return params;
        }

        Object.entries(currentStrategyConfig.parameters).forEach(([name, def]) => {
          const input = document.getElementById(`backtest_${name}`);
          if (!input) {
            return;
          }

          if (input.type === 'checkbox') {
            params[name] = Boolean(input.checked);
          } else if (input.type === 'number') {
            const value = parseFloat(input.value);
            const fallback = Object.prototype.hasOwnProperty.call(def, 'default') ? def.default : 0;
            params[name] = Number.isFinite(value) ? value : fallback;
          } else {
            params[name] = input.value;
          }
        });

        return params;
      }

      function applyDynamicBacktestParams(params) {
        if (!params || typeof params !== 'object') {
          return;
        }

        if (!currentStrategyConfig || !currentStrategyConfig.parameters) {
          return;
        }

        Object.entries(currentStrategyConfig.parameters).forEach(([name, def]) => {
          if (!Object.prototype.hasOwnProperty.call(params, name)) {
            return;
          }

          const input = document.getElementById(`backtest_${name}`);
          if (!input) {
            return;
          }

          const value = params[name];

          if (input.type === 'checkbox') {
            input.checked = Boolean(value);
          } else if (input.type === 'number') {
            input.value = value;
          } else if (input.tagName === 'SELECT') {
            input.value = value;
          } else {
            input.value = value;
          }
        });
      }

      function gatherFormState() {
        const start = composeDateTime(
          document.getElementById('startDate').value,
          document.getElementById('startTime').value
        );
        const end = composeDateTime(
          document.getElementById('endDate').value,
          document.getElementById('endTime').value
        );

        const dynamicParams = collectDynamicBacktestParams();

        const payload = {
          ...dynamicParams,
          dateFilter: document.getElementById('dateFilter').checked,
          backtester: document.getElementById('backtester').checked,
          start,
          end
        };

        return {
          start,
          end,
          payload
        };
      }

      function formatMetric(value, digits = 2) {
        if (typeof value === 'number' && Number.isFinite(value)) {
          return value.toFixed(digits);
        }
        return value ?? '‚Äî';
      }

      function formatResultBlock(index, total, payload, data) {
        const metrics = data.metrics || {};
        const trendLabel = payload.maType ? payload.maType : 'N/A';
        const trailLongLabel = payload.trailLongType ? payload.trailLongType : 'N/A';
        const trailShortLabel = payload.trailShortType ? payload.trailShortType : 'N/A';
        return [
          `#${index}/${total}`,
          `Trend MA: ${trendLabel}`,
          `Trail MA Long: ${trailLongLabel}`,
          `Trail MA Short: ${trailShortLabel}`,
          `Net Profit %: ${formatMetric(metrics.net_profit_pct)}`,
          `Max Drawdown %: ${formatMetric(metrics.max_drawdown_pct)}`,
          `Total Trades: ${metrics.total_trades ?? '‚Äî'}`
        ].join('\n');
      }

      function getRangeCount(from, to, step) {
        const delta = Math.abs(step);
        if (!delta) {
          return 0;
        }
        if (Number.isNaN(from) || Number.isNaN(to)) {
          return 0;
        }
        const distance = Math.abs(to - from);
        return Math.floor(distance / delta + 1e-9) + 1;
      }

      function getBacktestParamValue(paramName, paramDef = {}, dynamicParams = {}) {
        if (Object.prototype.hasOwnProperty.call(dynamicParams, paramName)) {
          return dynamicParams[paramName];
        }

        const input = document.getElementById(`backtest_${paramName}`);
        if (input) {
          if (input.type === 'checkbox') {
            return Boolean(input.checked);
          }
          if (input.type === 'number') {
            const value = Number(input.value);
            if (Number.isFinite(value)) {
              return value;
            }
          }
          return input.value;
        }

        if (Object.prototype.hasOwnProperty.call(paramDef, 'default')) {
          return paramDef.default;
        }

        return null;
      }

      function getWorkerProcessesValue() {
        const workerInput = document.getElementById('workerProcesses');
        let workerProcesses = defaults.workerProcesses;
        if (workerInput) {
          const rawValue = Number(workerInput.value);
          if (Number.isFinite(rawValue)) {
            workerProcesses = rawValue;
          }
        }
        return Math.round(Math.min(32, Math.max(1, workerProcesses)));
      }

      function formatEstimatedTimeValue(total, workerCount, barCount) {
        if (!Number.isFinite(total) || total <= 0) {
          return '-';
        }
        const normalizedWorkers = Math.round(
          Math.min(32, Math.max(1, Number.isFinite(workerCount) ? workerCount : defaults.workerProcesses))
        );
        const baseRate = (normalizedWorkers / 6) * 16;
        let combinationsPerSecond = baseRate;
        if (Number.isFinite(barCount) && barCount > 0) {
          combinationsPerSecond = baseRate * (REFERENCE_BAR_COUNT / barCount);
        }
        if (!Number.isFinite(combinationsPerSecond) || combinationsPerSecond <= 0) {
          return '-';
        }
        const seconds = total / combinationsPerSecond;
        if (seconds < 60) {
          return `${seconds.toFixed(1)} s`;
        }
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.round(seconds % 60);
        if (minutes < 60) {
          return `${minutes}m ${remainingSeconds.toString().padStart(2, '0')}s`;
        }
        const hours = Math.floor(minutes / 60);
        const remMinutes = minutes % 60;
        if (hours < 24) {
          return `${hours}h ${remMinutes}m`;
        }
        const days = Math.floor(hours / 24);
        const remHours = hours % 24;
        return `${days}d ${remHours}h`;
      }

      let latestBarCountRequestId = 0;

      function parseDateRangeForBars() {
        const startValue = composeDateTime(
          document.getElementById('startDate').value,
          document.getElementById('startTime').value
        );
        const endValue = composeDateTime(
          document.getElementById('endDate').value,
          document.getElementById('endTime').value
        );

        if (!startValue || !endValue) {
          return { error: 'Invalid date range' };
        }

        const startDate = new Date(startValue);
        const endDate = new Date(endValue);

        if (!Number.isFinite(startDate.valueOf()) || !Number.isFinite(endDate.valueOf())) {
          return { error: 'Invalid date range' };
        }

        if (endDate < startDate) {
          return { error: 'Invalid date range' };
        }

        return {
          startSec: Math.floor(startDate.getTime() / 1000),
          endSec: Math.floor(endDate.getTime() / 1000)
        };
      }

      function countBarsInCsvText(csvText, startSec, endSec) {
        if (!csvText || !Number.isFinite(startSec) || !Number.isFinite(endSec) || endSec < startSec) {
          return 0;
        }

        const lines = csvText.split(/\r?\n/);
        if (lines.length <= 1) {
          return 0;
        }

        let count = 0;
        for (let index = 1; index < lines.length; index += 1) {
          const line = lines[index].trim();
          if (!line) {
            continue;
          }

          const commaIndex = line.indexOf(',');
          const timePart = commaIndex >= 0 ? line.slice(0, commaIndex) : line;
          const timestamp = Number(timePart.trim());
          if (!Number.isFinite(timestamp)) {
            continue;
          }

          if (timestamp >= startSec && timestamp <= endSec) {
            count += 1;
          }
        }

        return count;
      }

      function countBarsInFile(file, startSec, endSec) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const text = typeof reader.result === 'string' ? reader.result : '';
              resolve(countBarsInCsvText(text, startSec, endSec));
            } catch (error) {
              reject(error);
            }
          };
          reader.onerror = () => {
            reject(reader.error || new Error('Failed to read CSV file'));
          };
          reader.readAsText(file);
        });
      }

      function updateEstimatedTime(total, workerCount) {
        if (!estimatedTimeEl) {
          return;
        }

        if (!Number.isFinite(total) || total <= 0) {
          estimatedTimeEl.textContent = '-';
          return;
        }

        const files = Array.from(csvFileInputEl?.files || []);
        if (!files.length) {
          if (selectedCsvPath) {
            estimatedTimeEl.textContent = 'ETA unavailable for saved path';
          } else {
            estimatedTimeEl.textContent = 'Load CSV for calculation';
          }
          return;
        }

        const dateRange = parseDateRangeForBars();
        if (!dateRange || dateRange.error) {
          estimatedTimeEl.textContent = dateRange?.error || 'Invalid date range';
          return;
        }

        const requestId = latestBarCountRequestId + 1;
        latestBarCountRequestId = requestId;
        estimatedTimeEl.textContent = 'Calculating‚Ä¶';

        Promise.all(files.map((file) => countBarsInFile(file, dateRange.startSec, dateRange.endSec)))
          .then((counts) => {
            if (requestId !== latestBarCountRequestId) {
              return;
            }

            const barCount = counts.reduce((acc, value) => acc + (Number.isFinite(value) ? value : 0), 0);
            if (!Number.isFinite(barCount) || barCount <= 0) {
              estimatedTimeEl.textContent = 'No data in range';
              return;
            }

            estimatedTimeEl.textContent = formatEstimatedTimeValue(total, workerCount, barCount);
          })
          .catch((error) => {
            if (requestId !== latestBarCountRequestId) {
              return;
            }
            console.error('Failed to calculate bar count from CSV', error);
            estimatedTimeEl.textContent = 'Failed to read CSV';
          });
      }

      function calculateTotalCombinations() {
        let total = 1;
        let valid = true;
        const canDisplay = Boolean(totalCombinationsEl && estimatedTimeEl);
        const paramElements = getOptimizerParamElements();

        if (!paramElements.length) {
          if (canDisplay) {
            totalCombinationsEl.textContent = '0';
            estimatedTimeEl.textContent = '-';
          }
          return 0;
        }

        paramElements.forEach(({ checkbox, fromInput, toInput, stepInput }) => {
          if (checkbox && checkbox.checked && fromInput && toInput && stepInput) {
            const from = Number(fromInput.value);
            const to = Number(toInput.value);
            const step = Number(stepInput.value);
            const count = getRangeCount(from, to, step);
            if (count <= 0) {
              valid = false;
            } else {
              total *= count;
            }
          }
        });

        if (!valid || !Number.isFinite(total)) {
          if (canDisplay) {
            totalCombinationsEl.textContent = '0';
            estimatedTimeEl.textContent = '-';
          }
          return total;
        }

        if (canDisplay) {
          const workerProcesses = getWorkerProcessesValue();
          totalCombinationsEl.textContent = total.toLocaleString('en-US');
          updateEstimatedTime(total, workerProcesses);
        }
        return total;
      }

      function collectOptimizerParams() {
        const ranges = {};

        const checkboxes = document.querySelectorAll(
          '[id^="opt-"]:not([id$="-from"]):not([id$="-to"]):not([id$="-step"])'
        );

        checkboxes.forEach((checkbox) => {
          if (checkbox.checked) {
            const paramName = checkbox.dataset.paramName || checkbox.id.replace('opt-', '');

            const fromInput = document.getElementById(`opt-${paramName}-from`);
            const toInput = document.getElementById(`opt-${paramName}-to`);
            const stepInput = document.getElementById(`opt-${paramName}-step`);

            if (fromInput && toInput && stepInput) {
              const fromValue = parseFloat(fromInput.value);
              const toValue = parseFloat(toInput.value);
              const stepValue = parseFloat(stepInput.value);

              if (isNaN(fromValue) || isNaN(toValue) || isNaN(stepValue)) {
                console.warn(`Invalid values for parameter ${paramName}, skipping`);
                return;
              }

              if (fromValue >= toValue) {
                console.warn(`From >= To for parameter ${paramName}, skipping`);
                return;
              }

              if (stepValue <= 0) {
                console.warn(`Invalid step for parameter ${paramName}, skipping`);
                return;
              }

              ranges[paramName] = [fromValue, toValue, stepValue];
            }
          }
        });

        return ranges;
      }

      function buildOptimizationConfig(state) {
        const enabledParams = {};
        const paramRanges = collectOptimizerParams();
        const fixedParams = {
          dateFilter: state.payload.dateFilter,
          backtester: state.payload.backtester,
          start: state.start,
          end: state.end
        };

        const { checkbox: minProfitCheckbox, input: minProfitInput } = getMinProfitElements();
        const filterEnabled = Boolean(minProfitCheckbox && minProfitCheckbox.checked);
        let minProfitThreshold = 0;
        if (minProfitInput) {
          const parsedValue = Number(minProfitInput.value);
          if (Number.isFinite(parsedValue)) {
            minProfitThreshold = Math.min(99000, Math.max(0, parsedValue));
          }
        }

        const dynamicParams = collectDynamicBacktestParams();
        const paramsDef = currentStrategyConfig?.parameters || {};
        const optimizableNames = new Set();

        getOptimizerParamElements().forEach(({ name, checkbox, fromInput, toInput, stepInput, def }) => {
          optimizableNames.add(name);
          const isChecked = Boolean(checkbox && checkbox.checked);
          enabledParams[name] = isChecked;

          if (isChecked && fromInput && toInput && stepInput && !paramRanges[name]) {
            const fromValue = Number(fromInput.value);
            const toValue = Number(toInput.value);
            const stepValue = Math.abs(Number(stepInput.value));
            if (
              Number.isFinite(fromValue) &&
              Number.isFinite(toValue) &&
              Number.isFinite(stepValue) &&
              stepValue > 0 &&
              fromValue < toValue
            ) {
              paramRanges[name] = [fromValue, toValue, stepValue];
            }
          } else {
            fixedParams[name] = getBacktestParamValue(name, def, dynamicParams);
          }
        });

        Object.entries(paramsDef).forEach(([name, def]) => {
          if (optimizableNames.has(name)) {
            return;
          }
          fixedParams[name] = getBacktestParamValue(name, def, dynamicParams);
        });

        const workerProcesses = getWorkerProcessesValue();

        const riskPerTrade = getBacktestParamValue('riskPerTrade', paramsDef.riskPerTrade, dynamicParams) || 0;
        const contractSize = getBacktestParamValue('contractSize', paramsDef.contractSize, dynamicParams) || 0;
        const commissionRate = getBacktestParamValue('commissionPct', paramsDef.commissionPct, dynamicParams);
        const atrPeriod = getBacktestParamValue('atrPeriod', paramsDef.atrPeriod, dynamicParams);

        return {
          enabled_params: enabledParams,
          param_ranges: paramRanges,
          fixed_params: fixedParams,
          risk_per_trade_pct: Number(riskPerTrade) || 0,
          contract_size: Number(contractSize) || 0,
          commission_rate: commissionRate !== undefined ? Number(commissionRate) || 0 : 0.0005,
          atr_period: atrPeriod !== undefined ? Number(atrPeriod) || 14 : 14,
          worker_processes: workerProcesses,
          filter_min_profit: filterEnabled,
          min_profit_threshold: minProfitThreshold,
          score_config: collectScoreConfig(),
          optimization_mode: 'optuna'
        };
      }

      function buildOptunaConfig(state) {
        const baseConfig = buildOptimizationConfig(state);
        const selectedBudget = Array.from(budgetModeRadios).find((radio) => radio.checked)?.value || 'trials';
        const trialsValue = Number(optunaTrials?.value);
        const timeLimitMinutes = Number(optunaTimeLimit?.value);
        const convergenceValue = Number(optunaConvergence?.value);
        const warmupValue = Number(optunaWarmupTrials?.value);

        const normalizedTrials = Number.isFinite(trialsValue) ? Math.max(10, Math.min(10000, Math.round(trialsValue))) : 500;
        const normalizedMinutes = Number.isFinite(timeLimitMinutes) ? Math.max(1, Math.round(timeLimitMinutes)) : 60;
        const normalizedConvergence = Number.isFinite(convergenceValue)
          ? Math.max(10, Math.min(500, Math.round(convergenceValue)))
          : 50;
        const normalizedWarmup = Number.isFinite(warmupValue) ? Math.max(0, Math.min(50000, Math.round(warmupValue))) : 20;

        return {
          ...baseConfig,
          optimization_mode: 'optuna',
          optuna_target: optunaTarget ? optunaTarget.value : 'score',
          optuna_budget_mode: selectedBudget,
          optuna_n_trials: normalizedTrials,
          optuna_time_limit: normalizedMinutes * 60,
          optuna_convergence: normalizedConvergence,
          optuna_enable_pruning: Boolean(optunaPruning && optunaPruning.checked),
          optuna_sampler: optunaSampler ? optunaSampler.value : 'tpe',
          optuna_pruner: optunaPruner ? optunaPruner.value : 'median',
          optuna_warmup_trials: normalizedWarmup,
          optuna_save_study: Boolean(optunaSaveStudy && optunaSaveStudy.checked)
        };
      }

      function clearWFResults() {
        if (wfResultsContainer) {
          wfResultsContainer.style.display = 'none';
        }
        if (wfSummaryEl) {
          wfSummaryEl.textContent = '';
        }
        if (wfTableBody) {
          wfTableBody.innerHTML = '';
        }
        if (wfStatusEl) {
          wfStatusEl.textContent = '';
        }
      }

      function displayWFResults(data) {
        if (!wfResultsContainer || !wfSummaryEl || !wfTableBody || !wfStatusEl) {
          return;
        }

        wfResultsContainer.style.display = 'block';
        wfStatusEl.textContent = '';

        const summary = data.summary || {};
        const totalWindowsValue = Number(summary.total_windows);
        const totalWindows = Number.isFinite(totalWindowsValue) ? totalWindowsValue : 0;
        const topParamId = summary.top_param_id || 'N/A';
        const topAvgValue = Number(summary.top_avg_oos_profit);
        const topAvgProfit = Number.isFinite(topAvgValue) ? topAvgValue : 0;

        wfSummaryEl.innerHTML = `
          <strong>Summary:</strong><br>
          Total Windows: ${totalWindows}<br>
          Best Parameter Set: ${topParamId}<br>
          Best Avg OOS Profit: ${topAvgProfit.toFixed(2)}%
        `;

        wfTableBody.innerHTML = '';
        (data.top10 || []).forEach((row) => {
          const avgValue = Number(row.avg_oos_profit);
          const winValue = Number(row.oos_win_rate);
          const forwardValue = row.forward_profit === null || row.forward_profit === undefined
            ? null
            : Number(row.forward_profit);
          const tr = document.createElement('tr');
          const avgOos = Number.isFinite(avgValue) ? avgValue.toFixed(2) : row.avg_oos_profit;
          const winRate = Number.isFinite(winValue) ? winValue.toFixed(1) : row.oos_win_rate;
          const forward = forwardValue === null || forwardValue === undefined || Number.isNaN(forwardValue)
            ? 'N/A'
            : `${forwardValue.toFixed(2)}%`;
          tr.innerHTML = `
            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${row.rank}</td>
            <td style="padding: 10px; border: 1px solid #ddd;">${row.param_id}</td>
            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${row.appearances}</td>
            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${avgOos}%</td>
            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${winRate}%</td>
            <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">${forward}</td>
          `;
          wfTableBody.appendChild(tr);
        });

        if (data.csv_content) {
          window.setTimeout(() => {
            const blob = new Blob([data.csv_content], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = data.csv_filename || `wf_results_${new Date().getTime()}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          }, 200);
        }
      }

      async function runWalkForward({ sources, state }) {
        if (!sources.length) {
          if (wfStatusEl) {
            wfStatusEl.textContent = 'Please select a CSV file before running Walk-Forward.';
          }
          return;
        }

        if (!currentStrategyId) {
          if (wfStatusEl) {
            wfStatusEl.textContent = 'Please select a strategy before running Walk-Forward.';
          }
          return;
        }

        const totalSources = sources.length;
        const config = buildOptunaConfig(state);
        const hasEnabledParams = Object.values(config.enabled_params || {}).some(Boolean);
        if (!hasEnabledParams) {
          if (wfStatusEl) {
            wfStatusEl.textContent = 'Please enable at least one parameter to optimize before running Walk-Forward.';
          }
          return;
        }

        // Get WFA parameters
        const wfNumWindows = document.getElementById('wfNumWindows').value;
        const wfGapBars = document.getElementById('wfGapBars').value;
        const wfTopK = document.getElementById('wfTopK').value;
        const exportTrades = document.getElementById('wfExportTrades').checked;
        const exportTopK = document.getElementById('wfExportTopK').value;

        // Prepare status tracking
        const statusMessages = new Array(totalSources).fill('');
        const updateStatus = (index, message) => {
          statusMessages[index] = message;
          if (wfStatusEl) {
            wfStatusEl.textContent = statusMessages.filter(Boolean).join('\n');
          }
        };

        // Clear previous results
        if (wfResultsContainer) {
          wfResultsContainer.style.display = 'block';
        }
        if (wfStatusEl) {
          wfStatusEl.textContent = '';
        }
        if (wfSummaryEl) {
          wfSummaryEl.textContent = '';
        }
        if (wfTableBody) {
          wfTableBody.innerHTML = '';
        }

        const errors = [];
        let successCount = 0;
        let lastSuccessfulData = null;

        // Process each source sequentially
        for (let index = 0; index < totalSources; index += 1) {
          const source = sources[index];
          const isFileObject = typeof File !== 'undefined' && source instanceof File;
          const rawSourceName = isFileObject ? source.name : source && source.path;
          const sourceName = rawSourceName || (isFileObject ? 'Unnamed file' : 'Saved path');
          const sourceNumber = index + 1;
          const fileLabel = `Processing source ${sourceNumber} of ${totalSources}: ${sourceName}`;

          updateStatus(index, `${fileLabel} ‚Äî running Walk-Forward‚Ä¶`);

          const formData = new FormData();
          formData.append('strategy', currentStrategyId);
          const warmupValue = document.getElementById('warmupBars')?.value || '1000';
          formData.append('warmupBars', warmupValue);
          if (isFileObject) {
            formData.append('file', source, source.name);
          } else if (source && source.path) {
            formData.append('csvPath', source.path);
          }

          formData.append('config', JSON.stringify(config));
          formData.append('wf_num_windows', wfNumWindows);
          formData.append('wf_gap_bars', wfGapBars);
          formData.append('wf_topk', wfTopK);
          formData.append('exportTrades', exportTrades ? 'true' : 'false');
          formData.append('topK', exportTopK);

          try {
            const response = await fetch('/api/walkforward', {
              method: 'POST',
              body: formData
            });

            // Always expect JSON response
            const data = await response.json();

            if (!response.ok || data.status !== 'success') {
              const message = data && data.error ? data.error : 'Walk-Forward request failed.';
              throw new Error(message);
            }

            // Download CSV if present (no trades export)
            // Skip download if single file - displayWFResults will handle it
            if (data.csv_content && totalSources > 1) {
              try {
                const blob = new Blob([data.csv_content], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = data.csv_filename || `wf_results_${Date.now()}.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
              } catch (csvError) {
                console.error('Failed to download CSV:', csvError);
              }
            }

            // Download ZIP if trades were exported
            if (data.export_trades && data.zip_base64) {
              try {
                // Decode base64 to binary
                const binaryString = atob(data.zip_base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }
                const blob = new Blob([bytes], { type: 'application/zip' });

                // Trigger download
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = data.zip_filename || `wf_results_${Date.now()}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
              } catch (zipError) {
                console.error('Failed to download ZIP:', zipError);
              }
            }

            updateStatus(index, `‚úÖ Source ${sourceNumber} of ${totalSources} (${sourceName}) completed successfully.`);
            successCount += 1;
            lastSuccessfulData = data;

          } catch (err) {
            const message = err && err.message ? err.message : 'Walk-Forward failed.';
            console.error(`Walk-Forward failed for source ${sourceName}`, err);
            errors.push({ file: sourceName, message });
            updateStatus(index, `‚ùå Source ${sourceNumber} of ${totalSources} (${sourceName}) failed: ${message}`);
          }
        }

        // Display summary
        if (successCount === totalSources) {
          const summaryMsg = totalSources === 1
            ? '‚úÖ Walk-Forward completed successfully.'
            : `‚úÖ All ${totalSources} files processed successfully.`;

          if (wfStatusEl) {
            wfStatusEl.textContent = summaryMsg + '\n\n' + statusMessages.filter(Boolean).join('\n');
          }

          // Display results table only if single file was processed
          if (totalSources === 1 && lastSuccessfulData) {
            displayWFResults(lastSuccessfulData);

            // Add trade export notice if applicable
            if (lastSuccessfulData.export_trades && wfSummaryEl) {
              const currentSummary = wfSummaryEl.innerHTML;
              wfSummaryEl.innerHTML = currentSummary + '<br><strong>Trade history exported!</strong> Downloaded ZIP contains WFA results CSV and individual trade history files.';
            }
          } else if (totalSources > 1 && wfSummaryEl) {
            // For multiple files, show a summary instead of individual results
            wfSummaryEl.innerHTML = `<strong>Multi-file Walk-Forward Analysis completed!</strong><br>Processed ${totalSources} files. Check downloaded CSV/ZIP files for detailed results.`;
          }
        } else if (successCount > 0) {
          const summaryMsg = `‚ö†Ô∏è ${successCount} of ${totalSources} files processed successfully, ${errors.length} failed.`;
          if (wfStatusEl) {
            wfStatusEl.textContent = summaryMsg + '\n\n' + statusMessages.filter(Boolean).join('\n');
          }

          // Show results for last successful file if only one succeeded
          if (successCount === 1 && lastSuccessfulData) {
            displayWFResults(lastSuccessfulData);
          }
        } else {
          const summaryMsg = `‚ùå All ${totalSources} files failed.`;
          if (wfStatusEl) {
            wfStatusEl.textContent = summaryMsg + '\n\n' + statusMessages.filter(Boolean).join('\n');
          }
        }
      }

      async function submitOptimization(event) {
        event.preventDefault();
        const fileInput = document.getElementById('csvFile');
        const fileList = fileInput ? Array.from(fileInput.files || []) : [];
        const sources = fileList.length ? fileList : (selectedCsvPath ? [{ path: selectedCsvPath }] : []);
        if (!sources.length) {
          optimizerResultsEl.textContent = 'Please select at least one CSV file or saved path before running optimization.';
          optimizerResultsEl.classList.remove('ready');
          optimizerResultsEl.style.display = 'block';
          return;
        }

        const state = gatherFormState();

        if (!currentStrategyId) {
          optimizerResultsEl.textContent = 'Please select a strategy before running optimization.';
          optimizerResultsEl.classList.remove('ready');
          optimizerResultsEl.style.display = 'block';
          return;
        }

        const wfEnabled = Boolean(document.getElementById('enableWF')?.checked);

        if (!state.start || !state.end) {
          optimizerResultsEl.textContent = 'Please specify both start and end dates before optimization.';
          optimizerResultsEl.classList.remove('ready');
          optimizerResultsEl.style.display = 'block';
          return;
        }

        if (wfEnabled) {
          clearWFResults();
          await runWalkForward({ sources, state });
          return;
        }

        if (fileList.length) {
          renderSelectedFiles(fileList);
        } else {
          renderSelectedFiles([]);
        }

        const config = buildOptunaConfig(state);
        const hasEnabledParams = Object.values(config.enabled_params || {}).some(Boolean);
        if (!hasEnabledParams) {
          optimizerResultsEl.textContent = 'Please enable at least one parameter to optimize.';
          optimizerResultsEl.classList.remove('ready');
          optimizerResultsEl.classList.remove('loading');
          optimizerResultsEl.style.display = 'block';
          return;
        }
        const totalSources = sources.length;
        const statusMessages = new Array(totalSources).fill('');
        const updateStatus = (index, message) => {
          statusMessages[index] = message;
          optimizerResultsEl.textContent = statusMessages.filter(Boolean).join('\n');
        };

        optimizerResultsEl.textContent = '';
        optimizerResultsEl.classList.add('loading');
        optimizerResultsEl.classList.remove('ready');
        optimizerResultsEl.style.display = 'block';

        progressContainer.style.display = 'block';
        if (optunaProgress) {
          optunaProgress.style.display = 'block';
        }
        if (optunaProgressFill) {
          optunaProgressFill.style.width = '0%';
        }
        if (optunaProgressText) {
          if (config.optuna_budget_mode === 'trials') {
            optunaProgressText.textContent = `Trial: 0 / ${config.optuna_n_trials.toLocaleString('en-US')} (0%)`;
          } else if (config.optuna_budget_mode === 'time') {
            const minutes = Math.round(config.optuna_time_limit / 60);
            optunaProgressText.textContent = `Time budget: ${minutes} min`;
          } else {
            optunaProgressText.textContent = 'Waiting for convergence threshold‚Ä¶';
          }
        }
        if (optunaBestTrial) {
          optunaBestTrial.textContent = 'Waiting for first trial...';
        }
        if (optunaCurrentTrial) {
          optunaCurrentTrial.textContent = 'Current trial: -';
        }
        if (optunaEta) {
          optunaEta.textContent = 'Est. time remaining: -';
        }

        const errors = [];
        let successCount = 0;
        const optunaBudgetMode = config.optuna_budget_mode;
        const plannedTrials = optunaBudgetMode === 'trials' ? config.optuna_n_trials : null;

        for (let index = 0; index < totalSources; index += 1) {
          const source = sources[index];
          const isFileObject = typeof File !== 'undefined' && source instanceof File;
          const rawSourceName = isFileObject ? source.name : source && source.path;
          const sourceName = rawSourceName || (isFileObject ? 'Unnamed file' : 'Saved path');
          const sourceNumber = index + 1;
          const fileLabel = `Processing source ${sourceNumber} of ${totalSources}: ${sourceName}`;

          updateStatus(index, `${fileLabel} ‚Äî processing‚Ä¶`);
          if (optunaProgressText) {
            if (plannedTrials) {
              optunaProgressText.textContent = `Trial: 0 / ${plannedTrials.toLocaleString('en-US')} (0%)`;
            } else if (optunaBudgetMode === 'time') {
              const minutes = Math.round(config.optuna_time_limit / 60);
              optunaProgressText.textContent = `Time budget: ${minutes} min ‚Äî running‚Ä¶`;
            } else {
              optunaProgressText.textContent = 'Running Optuna optimization‚Ä¶';
            }
          }
          if (optunaProgressFill) {
            optunaProgressFill.style.width = '0%';
          }

          const formData = new FormData();
          formData.append('strategy', currentStrategyId);
          const warmupValue = document.getElementById('warmupBars')?.value || '1000';
          formData.append('warmupBars', warmupValue);
          if (isFileObject) {
            formData.append('file', source, source.name);
          } else if (source && source.path) {
            formData.append('csvPath', source.path);
          }
          formData.append('config', JSON.stringify(config));

          try {
            const response = await fetch('/api/optimize', {
              method: 'POST',
              body: formData
            });

            if (!response.ok) {
              const message = await response.text();
              throw new Error(message || 'Optimization request failed.');
            }

            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;

            const disposition = response.headers.get('Content-Disposition');
            let downloadName = `optimization_${Date.now()}.csv`;
            if (disposition) {
              const utf8Match = disposition.match(/filename\*=UTF-8''([^;]+)/i);
              const asciiMatch = disposition.match(/filename="?([^";]+)"?/i);
              if (utf8Match && utf8Match[1]) {
                try {
                  downloadName = decodeURIComponent(utf8Match[1]);
                } catch (err) {
                  downloadName = utf8Match[1];
                }
              } else if (asciiMatch && asciiMatch[1]) {
                downloadName = asciiMatch[1];
              }
            }
            link.download = downloadName;
            document.body.appendChild(link);
            link.click();
            link.remove();
            window.URL.revokeObjectURL(url);

            if (optunaProgressFill) {
              optunaProgressFill.style.width = '100%';
            }
            if (optunaProgressText) {
              if (plannedTrials) {
                optunaProgressText.textContent = `Trial: ${plannedTrials.toLocaleString('en-US')} / ${plannedTrials.toLocaleString('en-US')} (100%)`;
              } else {
                optunaProgressText.textContent = 'Optuna optimization completed.';
              }
            }
            if (optunaBestTrial) {
              optunaBestTrial.textContent = 'Review the downloaded CSV to inspect the best trial and metrics.';
            }

            updateStatus(index, `‚úÖ Source ${sourceNumber} of ${totalSources} (${sourceName}) processed successfully.`);
            successCount += 1;
          } catch (err) {
            const message = err && err.message ? err.message : 'Optimization failed.';
            console.error(`Optimization failed for source ${sourceName}`, err);
            errors.push({ file: sourceName, message });

            if (optunaProgressFill) {
              optunaProgressFill.style.width = '0%';
            }
            if (optunaProgressText) {
              optunaProgressText.textContent = `Error: ${message}`;
            }

            updateStatus(index, `‚ùå Source ${sourceNumber} of ${totalSources} (${sourceName}) failed: ${message}`);
          }
        }

        optimizerResultsEl.classList.remove('loading');
        if (successCount > 0) {
          optimizerResultsEl.classList.add('ready');
        } else {
          optimizerResultsEl.classList.remove('ready');
        }

        const summaryMessages = statusMessages.filter(Boolean);
        if (successCount === totalSources) {
          summaryMessages.push(`Optimization complete! All ${totalSources} data source(s) processed successfully.`);
        } else if (successCount > 0) {
          summaryMessages.push(
            `Optimization finished with ${successCount} successful data source(s) and ${errors.length} error(s).`
          );
        } else {
          summaryMessages.push('Optimization failed for all selected data sources. See error details above.');
        }
        optimizerResultsEl.textContent = summaryMessages.join('\n');
      }

      function bindOptimizerInputs() {
        const checkboxes = document.querySelectorAll(
          '[id^="opt-"]:not([id$="-from"]):not([id$="-to"]):not([id$="-step"])'
        );

        checkboxes.forEach((checkbox) => {
          checkbox.removeEventListener('change', handleOptimizerCheckboxChange);
          checkbox.addEventListener('change', handleOptimizerCheckboxChange);
          checkbox.addEventListener('change', calculateTotalCombinations);
          handleOptimizerCheckboxChange.call(checkbox);
        });

        const numericInputs = document.querySelectorAll('#optimizerParamsContainer input[type="number"]');
        numericInputs.forEach((input) => {
          input.addEventListener('input', calculateTotalCombinations);
        });

        const workerInput = document.getElementById('workerProcesses');
        if (workerInput) {
          workerInput.addEventListener('input', calculateTotalCombinations);
        }

        const dateInputs = ['startDate', 'startTime', 'endDate', 'endTime'];
        dateInputs.forEach((inputId) => {
          const input = document.getElementById(inputId);
          if (input) {
            input.addEventListener('input', calculateTotalCombinations);
            input.addEventListener('change', calculateTotalCombinations);
          }
        });

        const lockEl = document.getElementById('opt-lockTrailTypes') || document.getElementById('trailLock');
        if (lockEl) {
          lockEl.removeEventListener('change', calculateTotalCombinations);
          lockEl.addEventListener('change', calculateTotalCombinations);
        }

        const maCheckboxes = document.querySelectorAll('#maTypeSelectorContainer input.opt-ma-type');
        if (maCheckboxes && maCheckboxes.length) {
          maCheckboxes.forEach((checkbox) => {
            checkbox.removeEventListener('change', calculateTotalCombinations);
            checkbox.addEventListener('change', () => {
              if (checkbox.dataset.type === 'ALL') {
                setCheckboxGroup(checkbox.dataset.group, checkbox.checked ? [...MA_TYPES] : []);
              } else {
                syncAllToggle(checkbox.dataset.group);
              }
              calculateTotalCombinations();
            });
          });
        }

        calculateTotalCombinations();
      }

      function handleOptimizerCheckboxChange() {
        const paramName = this.dataset.paramName || this.id.replace('opt-', '');
        const fromInput = document.getElementById(`opt-${paramName}-from`);
        const toInput = document.getElementById(`opt-${paramName}-to`);
        const stepInput = document.getElementById(`opt-${paramName}-step`);

        const disabled = !this.checked;

        if (fromInput) fromInput.disabled = disabled;
        if (toInput) toInput.disabled = disabled;
        if (stepInput) stepInput.disabled = disabled;

        const row = this.closest('.opt-row');
        if (row) {
          if (disabled) {
            row.classList.add('disabled');
          } else {
            row.classList.remove('disabled');
          }
        }
      }

      function bindMinProfitFilterControl() {
        const { checkbox, input } = getMinProfitElements();
        if (!checkbox || !input) {
          return;
        }

        checkbox.addEventListener('change', syncMinProfitFilterUI);
        syncMinProfitFilterUI();
      }

      function bindScoreControls() {
        const { checkbox, input } = getScoreElements();
        if (checkbox) {
          checkbox.addEventListener('change', () => {
            syncScoreFilterUI();
            updateScoreFormulaPreview();
          });
        }
        if (input) {
          input.addEventListener('input', updateScoreFormulaPreview);
        }

        SCORE_METRICS.forEach((metric) => {
          const metricCheckbox = document.getElementById(`metric-${metric}`);
          const weightInput = document.getElementById(`weight-${metric}`);
          if (metricCheckbox) {
            metricCheckbox.addEventListener('change', updateScoreFormulaPreview);
          }
          if (weightInput) {
            weightInput.addEventListener('input', updateScoreFormulaPreview);
          }
        });

        const invertCheckbox = document.getElementById('invert-ulcer');
        if (invertCheckbox) {
          invertCheckbox.addEventListener('change', updateScoreFormulaPreview);
        }

        const configButton = document.getElementById('scoreConfigBtn');
        const collapsible = document.getElementById('scoreConfigCollapsible');
        if (configButton && collapsible) {
          configButton.addEventListener('click', () => {
            const isOpen = collapsible.classList.toggle('open');
            configButton.setAttribute('aria-expanded', String(isOpen));
          });
        }

        const resetButton = document.getElementById('resetScoreBtn');
        if (resetButton) {
          resetButton.addEventListener('click', () => {
            applyScoreSettings({
              scoreFilterEnabled: false,
              scoreThreshold: SCORE_DEFAULT_THRESHOLD,
              scoreWeights: clonePreset(SCORE_DEFAULT_WEIGHTS),
              scoreEnabledMetrics: clonePreset(SCORE_DEFAULT_ENABLED),
              scoreInvertMetrics: clonePreset(SCORE_DEFAULT_INVERT),
            });
            updateScoreFormulaPreview();
          });
        }

        syncScoreFilterUI();
        updateScoreFormulaPreview();
      }

      async function runBacktest(event) {
        event.preventDefault();
        const resultsEl = document.getElementById('results');
        const errorEl = document.getElementById('error');
        const fileInput = document.getElementById('csvFile');

        errorEl.style.display = 'none';
        resultsEl.classList.remove('ready');

        const selectedFiles = Array.from(fileInput.files || []);
        const primaryFile = selectedFiles.length ? selectedFiles[0] : null;

        if (!primaryFile && !selectedCsvPath) {
          errorEl.textContent = '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ CSV —Ñ–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π –ø—É—Ç—å.';
          errorEl.style.display = 'block';
          return;
        }

        const state = gatherFormState();
        if (!state.start || !state.end) {
          errorEl.textContent = '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –¥–∞—Ç—ã –Ω–∞—á–∞–ª–∞ –∏ –æ–∫–æ–Ω—á–∞–Ω–∏—è.';
          errorEl.style.display = 'block';
          return;
        }

        if (!currentStrategyId) {
          errorEl.textContent = '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º —Ä–∞—Å—á—ë—Ç–∞.';
          errorEl.style.display = 'block';
          return;
        }

        const combinations = [{}];

        resultsEl.textContent = '–í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ä–∞—Å—á—ë—Ç‚Ä¶';
        resultsEl.classList.add('loading');

        const aggregatedResults = [];

        if (primaryFile) {
          renderSelectedFiles(selectedFiles);
        } else {
          renderSelectedFiles([]);
        }

        for (let index = 0; index < combinations.length; index += 1) {
          const combo = combinations[index];
          const payload = { ...state.payload };

          const formData = new FormData();
          formData.append('strategy', currentStrategyId);
          const warmupInput = document.getElementById('warmupBars');
          formData.append('warmupBars', warmupInput ? warmupInput.value : '1000');
          if (primaryFile) {
            formData.append('file', primaryFile, primaryFile.name);
          }
          if (selectedCsvPath) {
            formData.append('csvPath', selectedCsvPath);
          }
          formData.append('payload', JSON.stringify(payload));

          resultsEl.textContent = `–í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ä–∞—Å—á—ë—Ç‚Ä¶ (${index + 1}/${combinations.length})`;

          try {
            const response = await fetch('/api/backtest', {
              method: 'POST',
              body: formData
            });

            if (!response.ok) {
              const message = await response.text();
              throw new Error(message || '–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –±—ç–∫—Ç–µ—Å—Ç–∞');
            }

            const data = await response.json();
            aggregatedResults.push(formatResultBlock(index + 1, combinations.length, payload, data));
          } catch (err) {
            resultsEl.textContent = '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞.';
            resultsEl.classList.remove('loading');
            errorEl.textContent = err.message;
            errorEl.style.display = 'block';
            return;
          }
        }

        resultsEl.textContent = aggregatedResults.join('\n\n');
        resultsEl.classList.remove('loading');
        resultsEl.classList.add('ready');
      }

      if (presetToggleEl) {
        presetToggleEl.addEventListener('click', (event) => {
          event.stopPropagation();
          togglePresetMenu();
        });
      }

      if (presetMenuEl) {
        presetMenuEl.addEventListener('click', (event) => {
          event.stopPropagation();
          const actionButton = event.target.closest('.preset-action');
          if (!actionButton) {
            return;
          }
          const action = actionButton.dataset.action;
          if (action === 'apply-defaults') {
            handleApplyDefaults();
          } else if (action === 'save-as') {
            handleSaveAsPreset();
          } else if (action === 'save-defaults') {
            handleSaveDefaults();
          } else if (action === 'import') {
            handleImportAction();
          }
        });
      }

      if (presetImportInput) {
        presetImportInput.addEventListener('change', async (event) => {
          const file = event.target.files && event.target.files[0];
          if (!file) {
            presetImportInput.value = '';
            closePresetMenu();
            return;
          }
          try {
            const data = await importPresetFromCsv(file);
            applyPresetValues(data?.values || {}, { clearResults: false });
            const appliedKeys = Array.from(new Set(data?.applied || []));
            const appliedLabels = appliedKeys.map((key) => formatPresetLabel(key));
            const message = appliedLabels.length
              ? `–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –ø–∞—Ä–∞–º–µ—Ç—Ä—ã: ${appliedLabels.join(', ')}.`
              : '–ò–º–ø–æ—Ä—Ç –∏–∑ CSV –Ω–µ –∏–∑–º–µ–Ω–∏–ª –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.';
            showResultsMessage(message);
            clearErrorMessage();
          } catch (error) {
            showErrorMessage(error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ CSV.');
          } finally {
            presetImportInput.value = '';
            closePresetMenu();
          }
        });
      }

      document.addEventListener('click', (event) => {
        if (
          presetDropdownEl &&
          presetDropdownEl.classList.contains('open') &&
          !presetDropdownEl.contains(event.target)
        ) {
          closePresetMenu();
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closePresetMenu();
        }
      });

      document.getElementById('cancelBtn').addEventListener('click', () => {
        document.getElementById('backtestForm').reset();
        applyDefaults({ clearResults: true });
      });

      document.getElementById('backtestForm').addEventListener('submit', runBacktest);

      if (optimizerForm) {
        optimizerForm.addEventListener('submit', submitOptimization);
      }

      bindOptimizerInputs();
      bindMinProfitFilterControl();
      bindScoreControls();
      bindMASelectors();
      initializePresets();
    });
  </script>
</body>
</html>
