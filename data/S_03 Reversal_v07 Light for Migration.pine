// S_03 Reversal_v07 Light for Migration
// strategy-type: reversal
// Always-in-market - reverses on opposite signal
// No stops, no targets, no trailing
// @version=5
strategy(title="S_03 Reversal for Migration",
	 overlay=true,
	 initial_capital=100,
	 currency="USDT",
	 calc_on_order_fills=true,
	 calc_on_every_tick=true,
	 use_bar_magnifier=true,
	 fill_orders_on_standard_ohlc=true,
	 process_orders_on_close=true,
	 default_qty_type=strategy.percent_of_equity,
	 default_qty_value=100,
	 commission_type=strategy.commission.percent,
	 commission_value=0.05)


// Backtesting range Date Filter - is already exists no need to use this block of code, it's identical to S_01
useDateFilter   = input.bool(true, "Date Filer", inline="Use Date Filer")
startDate       = input.time(timestamp('2025-06-15'), title="Start Date")
endDate         = input.time(timestamp('2025-11-15'), title="End Date")

drawTester      = input.bool(title="Backtester", defval=true, inline="Use Date Filer")

// Trend moving average
maType3    = input.string(title="T MA Type", defval="SMA", options=["EMA", "SMA", "HMA", "WMA", "ALMA", "KAMA", "TMA", "T3", "DEMA", "VWMA", "VWAP"], inline="MA №3", group="MOVING AVERAGE")
maLength3  = input.int(title="Length", defval=100, minval=0, step=5, inline="MA №3", group="MOVING AVERAGE")
maColor3  = input.color(defval=color.rgb(166, 109, 176, 40), title="", inline="MA №3", group="MOVING AVERAGE")


// Trend break - how many closes above or below Trend moving average
closeCountLong    = input.int(title="Close Count Long", defval=4, minval=1, step=1, inline="Close Count", group="MOVING AVERAGE")
closeCountShort   = input.int(title="Close Count Short", defval=5, minval=1, step=1, inline="Close Count", group="MOVING AVERAGE")

contractsSize      = input.float(title="Contract Size", defval=0.01, options=[0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000, 10000, 100000, 1000000], group="MOVING AVERAGE")


// This block of code is for calculation of Moving Averages. This is already exists in Python project. This block of code is identical to S_01. Start from here =>
// Values for KAMA and T3 calculations
float fastKama = 2
float slowKama = 30
float factorT3 = 0.7

// gd function for T3 "Moving Average" calculation
gd(_maSource, _maLength) =>
    ta.ema(_maSource, _maLength) * (1 + factorT3) - ta.ema(ta.ema(_maSource, _maLength), _maLength) * factorT3

// Get selected "Moving Average" function
getMA(_maSource, _maType, _maLength) =>
    if _maLength == 0
        na
    else
        switch _maType
            "SMA" => ta.sma(_maSource, _maLength)
            "HMA" => ta.hma(_maSource, _maLength)
            "WMA" => ta.wma(_maSource, _maLength)
            "VWMA" => ta.vwma(_maSource, _maLength)
            "VWAP" => ta.vwap
            "ALMA" => ta.alma(_maSource, _maLength, 0.85, 6)
            "DEMA" =>
                e1 = ta.ema(_maSource, _maLength)
                e2 = ta.ema(e1, _maLength)
                2 * e1 - e2
            "KAMA" =>
                mom = math.abs(ta.change(_maSource, _maLength))
                volatility = math.sum(math.abs(ta.change(_maSource)), _maLength)
                er = volatility != 0 ? mom / volatility : 0
                fastAlpha = 2 / (fastKama + 1)
                slowAlpha = 2 / (slowKama + 1)
                alpha = math.pow(er * (fastAlpha - slowAlpha) + slowAlpha, 2)
                kama = 0.0
                kama := alpha * _maSource + (1 - alpha) * nz(kama[1], _maSource)
                kama
            "TMA" =>
                tma = ta.sma(ta.sma(_maSource, math.ceil(_maLength / 2)), math.floor(_maLength / 2) + 1)
            "T3" =>
                t3 = gd(gd(gd(_maSource, _maLength), _maLength), _maLength)
            => ta.ema(_maSource, _maLength)


// Get MA values
ma3             = getMA(close, maType3, maLength3)

// <= End of indentical to S_01 block of code

// Counters for trend break
var int counterCloseCountTrendLong  = 0
var int counterCloseCountTrendShort = 0

if close > ma3
    counterCloseCountTrendLong := counterCloseCountTrendLong + 1
    counterCloseCountTrendShort := 0
else if close < ma3
    counterCloseCountTrendShort := counterCloseCountTrendShort + 1
    counterCloseCountTrendLong := 0
else
    counterCloseCountTrendLong := 0
    counterCloseCountTrendShort := 0

countLong = counterCloseCountTrendLong >= closeCountLong
countShort = counterCloseCountTrendShort >= closeCountShort

// Check Dates Range
timeInRange = not useDateFilter or time >= startDate and time <= endDate

// Check long/short conditions
longConditions  = timeInRange and countLong and barstate.isconfirmed
shortConditions = timeInRange and countShort and barstate.isconfirmed

// Enter trade 
// Before enter we need to close previous trade, because this is reversal strategy
// If we go Long, first we need to close Short position
if longConditions and strategy.position_size < 0
    strategy.close("Short", comment="Close Short")

// If we go Short, first we need to close Long position
if shortConditions and strategy.position_size > 0
    strategy.close("Long", comment="Close Long")

// Entering and position size calculation for Long trade
if longConditions and strategy.position_size == 0 and strategy.position_size == 0[1] //We should open position on the next bar of bar where position was closed
    positionSize = math.floor((strategy.equity / close) / contractsSize) * contractsSize
    strategy.entry("Long", strategy.long, qty=positionSize)

// Entering and position size calculation for Short trade
if shortConditions and strategy.position_size == 0 and strategy.position_size == 0[1] //We should open position on the next bar of bar where position was closed
    positionSize = math.floor((strategy.equity / close) / contractsSize) * contractsSize
    strategy.entry("Short", strategy.short, qty=positionSize)


// Exit trade (any position - Long or Short) if we out of Date Range
if not timeInRange
    strategy.close_all("Close")

// @skip-translation-start from this till the end is Pine-specific code for stats and plotting, skip from this
// Leverage counter
var leverageSize = 1

entryBarLong = strategy.position_size[1] < 0 and strategy.position_size > 0
entryBarShort = strategy.position_size[1] > 0 and strategy.position_size < 0

// Days counters
var int entryTime = na
var float maxDaysInTrade = 0.0

if strategy.opentrades > 0 and na(entryTime)
    entryTime := time

if strategy.opentrades > 0 and not na(entryTime)
    daysInTrade = (time - entryTime) / (1000 * 60 * 60 * 24)
    if daysInTrade > maxDaysInTrade
        maxDaysInTrade := daysInTrade

if strategy.opentrades == 0 and not na(entryTime)
    entryTime := na

// Draw MAs
plot(ma3, color=maColor3, linewidth=2, title="MA №3")

plotshape(entryBarLong, style=shape.circle, location=location.top, color=color.gray, size=size.tiny, transp=80)
plotshape(entryBarShort, style=shape.circle, location=location.top, color=color.gray, size=size.tiny, transp=80)

// Prepare stats table
var table testTable = table.new(position.bottom_left, 2, 5, border_width=1, border_color=color.black, frame_color=color.black, frame_width=1)
f_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>
    _cellText = _title + "\n" + _value
    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor)

// Draw stats table
var bgcolor = #f3f3f3
if barstate.islastconfirmedhistory
    if drawTester
        f_fillCell(testTable, 0, 0, "WR:", str.tostring(math.floor(strategy.wintrades / strategy.closedtrades * 100)) + "%", bgcolor, (math.floor(strategy.wintrades / strategy.closedtrades * 100)) > 45 ? #6caf5d : color.black)
        f_fillCell(testTable, 1, 0, "PnL:", str.tostring(math.floor(strategy.netprofit_percent)) + "%", bgcolor, (math.floor(strategy.netprofit_percent)) <= 0 ? #a73302 : color.black)
        f_fillCell(testTable, 0, 1, "DD:", str.tostring(math.ceil(strategy.max_drawdown_percent)) + "%", bgcolor, (math.ceil(strategy.max_drawdown_percent)) > 20 ? #a73302 : color.black)
        f_fillCell(testTable, 1, 1, "Trades:", str.tostring(strategy.closedtrades), bgcolor, color.black)
        f_fillCell(testTable, 1, 3, "Lev:", str.tostring(leverageSize), bgcolor, leverageSize >= 10 ? #a73302 : color.black)
        f_fillCell(testTable, 0, 4, "Max D:", str.tostring(math.ceil(maxDaysInTrade)), bgcolor, color.black)

// @skip-translation-end