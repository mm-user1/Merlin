"""
Parity and regression tests for metrics extraction (Phase 4).

These tests verify that the metrics.py implementation produces
bit-exact identical values to the metrics attached to StrategyResult
instances generated by the backtest engine.
"""
from pathlib import Path
import json
import sys

import pandas as pd
import pytest

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from core.backtest_engine import (  # noqa: E402
    StrategyParams,
    StrategyResult,
    TradeRecord,
    load_data,
    prepare_dataset_with_warmup,
    run_strategy,
)
from core.metrics import (  # noqa: E402
    calculate_basic,
    calculate_advanced,
)

PROJECT_ROOT = Path(__file__).parent.parent
DATA_PATH = PROJECT_ROOT / "data" / "raw" / "OKX_LINKUSDT.P, 15 2025.05.01-2025.11.20.csv"
BASELINE_PATH = PROJECT_ROOT / "data" / "baseline" / "s01_metrics.json"


@pytest.fixture(scope="module")
def test_data():
    df = load_data(str(DATA_PATH))
    return df


@pytest.fixture(scope="module")
def baseline_params():
    with open(BASELINE_PATH, "r") as f:
        baseline = json.load(f)
    return baseline["parameters"], baseline


@pytest.fixture(scope="module")
def test_result(test_data, baseline_params):
    params_dict, baseline = baseline_params
    params = StrategyParams.from_dict(params_dict)

    start_ts = pd.Timestamp(params_dict["start"], tz="UTC")
    end_ts = pd.Timestamp(params_dict["end"], tz="UTC")
    warmup_bars = baseline["warmup_bars"]

    df_prepared, trade_start_idx = prepare_dataset_with_warmup(
        test_data, start_ts, end_ts, warmup_bars
    )

    result = run_strategy(df_prepared, params, trade_start_idx)
    return result


class TestMetricsParity:
    """Test parity between StrategyResult values and metrics module."""

    def test_basic_net_profit_matches(self, test_result):
        basic = calculate_basic(test_result)
        assert basic.net_profit == pytest.approx(test_result.net_profit)
        assert basic.net_profit_pct == pytest.approx(test_result.net_profit_pct)

    def test_basic_drawdown_matches(self, test_result):
        basic = calculate_basic(test_result)
        assert basic.max_drawdown == pytest.approx(test_result.max_drawdown)
        assert basic.max_drawdown_pct == pytest.approx(test_result.max_drawdown_pct)

    def test_basic_trade_counts_match(self, test_result):
        basic = calculate_basic(test_result)
        assert basic.total_trades == test_result.total_trades
        assert basic.winning_trades == test_result.winning_trades
        assert basic.losing_trades == test_result.losing_trades

    def test_advanced_profit_factor_matches(self, test_result):
        advanced = calculate_advanced(test_result)
        assert advanced.profit_factor == pytest.approx(test_result.profit_factor)

    def test_advanced_romad_matches(self, test_result):
        advanced = calculate_advanced(test_result)
        assert advanced.romad == pytest.approx(test_result.romad)

    def test_advanced_ulcer_matches(self, test_result):
        advanced = calculate_advanced(test_result)
        assert advanced.ulcer_index == pytest.approx(test_result.ulcer_index)

    def test_advanced_consistency_matches(self, test_result):
        advanced = calculate_advanced(test_result)
        assert advanced.consistency_score == pytest.approx(test_result.consistency_score)


class TestMetricsEdgeCases:
    """Test metrics calculation with edge scenarios."""

    def test_zero_trades(self):
        result = StrategyResult(
            trades=[],
            equity_curve=[10000.0],
            balance_curve=[10000.0],
            timestamps=[pd.Timestamp("2025-01-01", tz="UTC")],
        )

        basic = calculate_basic(result)
        advanced = calculate_advanced(result)

        assert basic.total_trades == 0
        assert basic.net_profit_pct == 0.0
        assert basic.win_rate == 0.0
        assert basic.avg_win == 0.0
        assert basic.avg_loss == 0.0
        assert advanced.profit_factor is None
        assert advanced.sharpe_ratio is None

    def test_all_winning_trades(self):
        trades = [
            TradeRecord(
                direction="Long",
                entry_time=pd.Timestamp("2025-01-01", tz="UTC"),
                exit_time=pd.Timestamp("2025-01-02", tz="UTC"),
                entry_price=100.0,
                exit_price=110.0,
                size=1.0,
                net_pnl=10.0,
            ),
            TradeRecord(
                direction="Long",
                entry_time=pd.Timestamp("2025-01-03", tz="UTC"),
                exit_time=pd.Timestamp("2025-01-04", tz="UTC"),
                entry_price=110.0,
                exit_price=120.0,
                size=1.0,
                net_pnl=10.0,
            ),
            TradeRecord(
                direction="Long",
                entry_time=pd.Timestamp("2025-01-05", tz="UTC"),
                exit_time=pd.Timestamp("2025-01-06", tz="UTC"),
                entry_price=120.0,
                exit_price=130.0,
                size=1.0,
                net_pnl=10.0,
            ),
        ]

        result = StrategyResult(
            trades=trades,
            equity_curve=[10000, 10010, 10020, 10030],
            balance_curve=[10000, 10010, 10020, 10030],
            timestamps=[
                pd.Timestamp("2025-01-01", tz="UTC"),
                pd.Timestamp("2025-01-02", tz="UTC"),
                pd.Timestamp("2025-01-04", tz="UTC"),
                pd.Timestamp("2025-01-06", tz="UTC"),
            ],
        )

        basic = calculate_basic(result)
        advanced = calculate_advanced(result)

        assert basic.total_trades == 3
        assert basic.winning_trades == 3
        assert basic.losing_trades == 0
        assert basic.win_rate == 100.0
        assert basic.gross_profit == 30.0
        assert basic.gross_loss == 0.0
        assert advanced.profit_factor == 999.0

    def test_all_losing_trades(self):
        trades = [
            TradeRecord(
                direction="Long",
                entry_time=pd.Timestamp("2025-01-01", tz="UTC"),
                exit_time=pd.Timestamp("2025-01-02", tz="UTC"),
                entry_price=100.0,
                exit_price=90.0,
                size=1.0,
                net_pnl=-10.0,
            ),
        ]

        result = StrategyResult(
            trades=trades,
            equity_curve=[10000, 9990],
            balance_curve=[10000, 9990],
            timestamps=[
                pd.Timestamp("2025-01-01", tz="UTC"),
                pd.Timestamp("2025-01-02", tz="UTC"),
            ],
        )

        basic = calculate_basic(result)
        advanced = calculate_advanced(result)

        assert basic.winning_trades == 0
        assert basic.losing_trades == 1
        assert basic.win_rate == 0.0
        assert advanced.profit_factor == 0.0


class TestMetricsRegression:
    """Regression checks against recorded baseline values."""

    def test_baseline_basic_matches(self, test_result, baseline_params):
        _, baseline = baseline_params
        expected_net_profit_pct = baseline["net_profit_pct"]
        expected_max_dd_pct = baseline["max_drawdown_pct"]
        expected_trades = baseline["total_trades"]

        basic = calculate_basic(test_result)

        assert abs(basic.net_profit_pct - expected_net_profit_pct) < 0.01
        assert abs(basic.max_drawdown_pct - expected_max_dd_pct) < 0.01
        assert basic.total_trades == expected_trades

    def test_baseline_advanced_matches(self, test_result, baseline_params):
        _, baseline = baseline_params
        advanced = calculate_advanced(test_result)

        assert abs((advanced.sharpe_ratio or 0) - baseline["sharpe_ratio"]) < 1e-6
        assert abs((advanced.profit_factor or 0) - baseline["profit_factor"]) < 1e-6
        assert abs((advanced.romad or 0) - baseline["romad"]) < 1e-6
        assert abs((advanced.ulcer_index or 0) - baseline["ulcer_index"]) < 1e-6
        assert abs((advanced.consistency_score or 0) - baseline["consistency_score"]) < 1e-6
